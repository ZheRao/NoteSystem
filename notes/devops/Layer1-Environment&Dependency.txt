


0 connection with Linux 

    - why?
        -- understand the magic behinding system determining which python interpreter to chooce as we move into different directories and venvs  

    - understand the layers envolved 

        -- layered view - detail

            --- layer0 - OS layer
                ---- tool and scope: Linux + PATH & whole machine 
                ---- what it does: decide which executable runs when you type 'python'
            
            --- layer1 - pyenv layer 
                ---- tool and scope: pyenv + shims & per-directory / global
                ---- what it does: decide which python interpreter version is active 
            
            --- layer2 - venv / Poetry layer 
                ---- tool and scope: virtualenv/Poetry & per-project 
                ---- what it does: descides which packages are active (site-packages)
        
        -- mental model 
                Shell (bash/zsh)
                    └─ PATH → pyenv shims
                        └─ points to a Python interpreter (3.11, 3.12, etc.)
                            └─ may be running inside a Poetry/venv environment
                                    └─ which contains isolated packages
        
        -- quick summary 
            --- when 'cd' into a directory 
                ---- pyenv may auto-switch the interpreter
                ---- Poetry/venv may auto-switch the packages 
    
    - clarify 'pyenv global/local/shell'

        -- pyenv global 
            --- writes the chosen version to '~/.pyenv/version'
            --- affects all shells where no local version overrides it 
            --- think of it as "default Python version for your entire user account"
        
        -- pyenv local 
            --- writes a '.python-version' file into the current directory 
            --- when you 'cd' into that directory (or any subdirectory), 'pyenv':
                ---- reads '.python-version'
                ---- activates that Python version automatically 
            --- overrides 'global' only inside this directory tree 
        
        -- pyenv shell 
            --- temporary override just for this terminal session 
            --- resets when you close the shell 
    
    - how it interacts with venv / Poetry 

        -- gist
            --- pyenv controls "which Python binary" runs
            --- venv control which "site-packages" that binary uses 

        -- when you create a venv (via built-in 'venv' or Poetry)
            --- the base interpreter used is whatever 'python' currently points to (i.e., the one pyenv selected)
            --- once created, the venv keeps a hard reference to that interpreter's path 
        
        -- so if pyenv later switches globally, your old venv doesn't break - it keeps using the interpreter it was born with 
            --- that's why it is safe to do 
                ---- 'pyenv local 3.11.9'
                ---- 'poetry env use python'    # will pick pyenv's current 3.11.9
            --- even if later 'pyenv global 3.12.3' - your project venv will still be 3.11.9-based
        
            




1 Python Installations and Version Conflicts 

    - goal - to understand 
        -- how multiple Python versions can exist on your system 
        -- why system Python must reamin untouched 
        -- how to inspect, install, and switch between interpreters safely (espeically using 'pyenv')
        -- how to avoid PATH confusion and library mismatches 
    
    - understanding versioning & compatibility 

        -- Python uses "semantic versioning"

            --- MAJOR.MINOR.Micro -> e.g., 3.11.7 
                ---- MAJOR -> backward-incompatible (Python 2 -> 3)
                ---- MINOR -> backward-compatible feature release (3.10 -> 3.11 adds pattern matching)
                ---- MICRO -> bug/security fixes (3.11.6 -> 3.11.7)
            
            --- a project written for 3.11 usually runs fine on 3.11.7, but fail on 3.8 if newer syntax is used 
        
    - why should never replace system python 

        -- system python is the interpreter your OS uses for core utilities (e.g., Ubuntu 22.04 uses '/usr/bin/python3.10')
            --- if you upgrade or remove it manually, package managers or scripts relying on that version can break (e,g,m 'apt', 'yum', or GNOME utilities)
            --- you should leave '/usr/bin/python3' alone and install additional interpreters in user space via 'pyenv', 'conda', or 'brew'
    
    - discovering installed Python version 

        -- Linux / macOS 
            --- which python                            # shows what executable is being run (shim or real one)
            --- which python3
            --- pyenv version                           # shows which pyenv version is currently active and why 
            --- python3 --version                       # sanity check interpreter version 
            --- ls /usr/bin/python*
            --- echo $PATH | tr ':' '\n' | grep pyenv   # shows where pyenv's shims sit in your PATH 

        
        -- this helps diagnose which interpreter your shell is using - often the root of version confusion 

        -- what is "shim"

            --- it is a tiny, fake executable that acts as a middleman between command and the real program
            
            --- when you type 'python3'
                ---- shell doesn't directly run '/usr/bin/python3' (the system binary)
                ---- instead if '~/.pyenv/shims' comes first in $PATH, the shell finds '~/.pyenv/shims/python3'
                ---- that file is a small script (the shim) which then 
                        -> checks your current directory (and parents) for a '.python-version' file
                        -> asks pyenv "Hey, which Python version should I use right now?"
                        -> pyenv looks up the version you set via 
                            --> 'pyenv local' (per-project)
                            --> 'pyenv shell' (temporary)
                            --> 'pyenv global' (default)
                        -> once pyenv decides (say, 3.11.9), the shim forwards the command to the real binary '~/.pyenv/versions/3.11.9/bin/python3'
                        -> you never notice - except that 'python3 --version' changes based on your directory 
        
        -- how does the shell determines which Python to use? 

        

        































Environments

    - Python virtual environments with 'venv'

        -- motive: virtual environment allows to manage dependecies separately for different projects, preventing conflicts and maintaining clearner setups 

        -- work with virtual environment 

            --- quick notes

                ---- why use '-m' in 'python3 -m pip...'?
                        -> if you have multiple Pythons installed, plain 'pip' might point at a different interpreter than you expect
                        -> 'python3 -m pip' removes that ambiguity
                        -> '-m' tells Python: run a module as a script 

            --- create: 'python3 -m venv .venv_name/'
                ---- 'venv' - specifies the module 
                ---- '.venv_name/' sets the name for your virtual environment
                        -> don't need the '/', but it's clearer that you're creating a folder 
            
            --- activate: 'source .venv_name/bin/activate'
                ---- make sure you're in the folder containing the virtual environment
            
            --- install package: 'python -m pip install <package-name>'
                ---- because you first created and activated the virtual environment, pip will install the packages in an isolated location
                ---- don't need to use 'python3' because it will automatically use the venv's interpreter (safe)
            
            --- deactivate: 'deactivate'
        
        -- why do we need virtual environments?

            --- short answer: Python isn't great at dependency management; if you are not specific, the pip will place all the external packages that you install in 'site-packages/'

            --- issues venv mitigate 

                ---- avoid System Pollution 
                        -> Linux and macOs come preinstalled with a version of Python that the OS uses for internal tasks 
                        -> install packages to this global Python will mix these packages with the system-relevant packages - unexpected side effects on OS's normal behavior 
                        -> updating OS could overwrite packages you installed or just lose them 
                
                ---- sidestep dependency conflicts 
                        -> you won't be able to work with two different versions of the same library if there's only one place to install packages
                
                ---- dodge installation privilege lockouts 
                        -> may need administrator privileges on a computer to install packages into the host Python's site-packages directory 
                        -> in a corporate work environment, you most likely won't have that level of access to the machine that you're working on 
                        -> in virtual environments, you create a new installation location within the scope of your user privileges, which allows you to install and work with external packages 
                
        -- base installation detailed look 

            --- philosophy: Python virtual environment is a folder structure that gives you everything you need to run a lightweight yet isolated Python environment 
                ---- to achieve this, 'venv' reproduces the folder structure that a standard Python installation creates 

            --- folder structure 

                ---- bin/ : executable files of the virtual environment 
                        -> Python interpreter (python) and the pip executable (pip), and their respective symlinks (python3, python3.12, pip3, pip3.12)
                        -> activation scripts for the virtual environment 
                
                ---- include/ : an initial empty folder that Python uses to include C header files for packages you might install that depend on C extensions 

                ---- lib/ : contains the site-package/ directory nested in a folder that designates the Python version (python3.12/)
                        -> site-package/ is one of the main reasons for creating the virtual environment 
                        -> this folder is where you'll install the external packages that you want to use within your virtual environment 
                        -> since Python 3.12, your virtual environment comes preinstalled with only one dependency, pip 
                
                ---- lib64/ : in many Linux systems comes as a symlink to lib/ for compatibility reasons 

                ---- {name}-{version}.dist-info/ : default directory for pip
                        -> contains package distribution information that exists to record information about installed packages 
                
                ---- pyvenv.cfg : contains only a couple of key-value pairs that Python uses to set variables in the 'sys' module that determine which Python interpreter and site-packages directory the current Python session will use 

            --- standard Python library
                ---- you will notice that this lightweight installation doesn't contain any of the trusted standard library modules, but you can still access all of them 
                ---- your virtual environment reuses Python's built-ins and standard-library modules from the Python installation you used to create your virtual environment 
            
            --- 'python3 -m venv .venv_name/ --system-site-packages': optionally give virtual environment access to the base installation's site-packages 
                ---- you can use any external packages that you installed to your base Python as if you'd installed them into your virtual environment 
                ---- this connection works in only one direction - new packages installed into virtual environment won't mingle with the packages in base Python 
        
        -- how the folder structre and the settings in 'pyvenv.cfg' file interact with Python to provide a reproducible and isolated space for installing external dependencies 

            --- copies structure and files 
                ---- when create a virtual environment using 'venv', the module re-creates the file and folder structure of a standard Python installation on OS 
                        -> Python also copies or symlinks into that folder structure the Python executable with which you created as 'venv_name'
                ---- base Python installation that the virtual environment is based on can be find under the 'home' key in 'pyvenv.cfg'
            
            --- adapts prefix-finding process 
                ---- Python interpreter in virtual envrionment now can understand where all relevant files are located because of the standard folder structure 
                ---- it is done with minor adaptions to its prefix-finding process 
                ---- instead of looking for the 'os' module to deterine the location of the standard library, interpreter first looks for a 'pyvenv.cfg' file 
                ---- if the file is located and contains a 'home' key, then the interpreter will use that key to set the value for two variables 
                        -> 'sys.base_prefic' hold the path to Python executable used to create this virtual envrionment 
                        -> 'sys.prefix' point to the directory containing 'pyvenv.cfg'
                ---- this change allows the Python interpreter in the virtual environment to 
                        -> use the standard-library modules from base Python installation 
                        -> point to its internal site-packages directory to install and access external packages 
                
            --- 'sys.path'
                ---- Python executable in virtual environment has access to standard-library modules because Python points to that file path in the 'home' setting in 'pyvenv.cfg'
                ---- Python is set up to find these modeuls by adding the relevant path to 'sys.path'
                ---- the paths that Python session has access to in 'sys.path' determine which locations Python can import modules from 
            
            --- modifies PYTHONPATH 
                ---- to ensure scripts use the Python interpreter within the virtual environment, 'venv' modifies the PYTHONPATH environment variable that can be accessed using 'sys.path'
                ---- if inspect 'sys.path' without an activate virtual environment - contains path to the site-packages directory - contains external modules that would be installed 
                        >>> import sys
                        >>> sys.path
                        [...
                        '/usr/local/lib/python3.12/site-packages']
                ---- with activated virtual environment - Python replaced the default site-packages directory path with the one that lives inside virtual environment while base Python's site-package isn't here
                        >>> import sys
                        >>> sys.path
                        [...
                        '/home/name/path/to/venv/lib/python3.12/site-packages']
                ---- optionally, you can get read-only access to the system site-packages directory of base Python installation 
            
            --- changes your shell PATH variable on activation 
                ---- to activate virtual environment: you run 'source .venv_name/bin/activate'
                ---- there are a few different activation scripts inside bin/ - all same purpose, distributor need to provide different ways to accomodate various OSs and shells  
                        venv/
                        │
                        ├── bin/
                        │   ├── Activate.ps1
                        │   ├── activate
                        │   ├── activate.csh
                        │   ├── activate.fish
                        ... ...
                ---- two critical actions in activation scripts 
                        -> Path: sets the VIRTUAL_ENV variable to the root folder path of your virtual environment and prepends the relative location of its Python executable to PATH 
                            --> path to all the executables in virtual environment now lives at the front of your PATH 
                            --> shell will invoke the internal versions of 'pip' or Python when you type 'pip' or 'python'
                        -> Command Prompt: changes the command prompt to the name of the virtual environment 
                ---- when 'deactivate', shell reverses these changes and returns PATH and your command prompt back to how they were before 
            
            --- it runs from anywhere with absolute path 
                ---- you can work with virtual environment without activating it 
                ---- if the name of an executable is provided to your shell, it'll look at the location recorded in PATH for an executable file sporting that name
                        -> it sill then pick and run the first one that matches that criterion
                        -> the activation script changes PATH variable so that the binaries folder of virtual environment is the first place your shell looks for executables 
                ---- if you don't activate virtual environment, you can pass the absolute path of the Python executable inside your virtual environment to run script
                ---- why?
                        -> embed activation in script is unstable
                        -> use absolute path to the Python interpreter in your virtual environment when running scripts 
                ---- how? 
                        0 * * * *
                        /home/name/Documents/connectivity-checker/venv/bin/python
                        -m rpchecker
                        -u google.com twitter.com
                        -a
                            --> 0 * * * * : Cron schedule: run at minute 0 every hour 
                            --> /home... : Python interpreter inside your virtual environment - this avois activation entirely and guarantees the venv's packages are used 
                            --> -m rpchecker : run the module rpchecker as a script - equivalent to 'python path/to/module/_main_.py'
            
        -- customize a virtual environment 

            --- update core dependencies 
                ---- 'python3 -m venv venv/ --upgrade-deps'
                ---- this only affects the dependencies upgrade at creation time - still need manual upgrade months later and you want new tooling 
                
            --- include the system site-packages 
                ---- 'python3 -m venv venv/ --system-site-packages'
                    >>> sys.path
                    [...
                    '/home/name/.local/lib/python3.12/site-packages',       # user site 
                    '/usr/local/lib/python3.12/site-packages']              # system site 
            
            --- copy or link executables
                ---- Linux distributions may create either a symlink or a copy, but often opt for synlinks over copies
                ---- if virtualenv copies and later base Python was updated 
                        -> 'python3 -m venv venv/ --upgrade'

        -- how to manage virtual environments 

            --- decide where to create environment folders 

                ---- inside each project folder 
                            project_name/
                            │
                            ├── venv/
                            │
                            └── src/
                        -> pros: tracibility - which virtualenv belongs to which project; easy activate with short relative path 
                
                ---- single-folder approach 
                            name/
                            │
                            ├── Documents/
                            │   │
                            │   └── projects/
                            │       │
                            │       ├── django-project/
                            │       │
                            │       ├── flask-project/
                            │       │
                            │       └── pandas-project/
                            │
                            ├── venvs
                            │   │
                            │   ├── django-venv/
                            │   │
                            │   ├── flask-venv/
                            │   │
                            │   └── pandas-venv/
                        -> pros - easy to manage virtualevns
                        -> cons - absolute path activation

            --- requirements.txt 

                ---- goal: be able to re-create Python environment on a different computer 
                        -> Q: how can you do that when you treat virtualenv as disposable and don't commit it to version control?
                
                ---- pin dependencies: need a way to describe its contents 
                        -> create a requirements.txt file while virtual environment is active 
                        -> '(venv) $ python -m pip freeze > requirements.txt'
                        -> 'pip freeze' - prints every installed Python package with its exact version in a format that pip can read back 
                            --> only a installation snapshot 
                        -> 'python -m pip freeze --local > requirements.txt' if created venv with '--system-site-packages'
                
                ---- install dependencies 
                        -> '(new-venv) $ python -m pip install -r requirements.txt'

                ---- danger 
                        -> Python version: requirements.txt doesn't include information about which version of Python used as base Python interpreter when creating the virtual environment 
                        -> sub-dependencies: it may not include version information about sub-dependencies of your dependencies 

                ---- potential solutions to danger 
                        -> requirements.txt using pip-tools 
                        -> Pipfile.lock using Pipenv 
                        -> poetry.lock using Poetry 
            
            --- avoid virtualevns in Production - why we need containers

                ---- bad idea to include virtual environment folder in remote online locations:
                        -> GitHub: don't push the venv/ folder to GitHub 
                        -> CI/CD pipelines: don't cinlude venv/ folder in continuous integration or continuous delivery pipelines 
                        -> server deployments: don't set up a virtual environment on deployment server unless you manage the server yourself and run multiple separate projects on it 
                
                ---- achieve isolated environments and reproducibility by pinning dependecies 
                        -> many remote hosting providers, including CI/CD pipeline tools and PaaS providers will automatically create that isolation for you 
                        -> in most hosted situations, you don't have to deal with creaing the isolation, you'll still need to provide the information about what to install in the remote env 
                            --> use pinned dependencies in 'requirements.txt' file 
                
                ---- a popular option that takes virtualization to the next level and still allows you to create a lot of the setup yourself is Docker 

                ---- third-party tools to manage multiple virtual environments 
                        -> virtualenvwrapper
                        -> Poetry 
                        -> uv
                        -> Hatch 
                        -> Pipenv 
                        -> pipx 
                        -> pipx-in-pipx 
                        -> pyenv-virtualenv 






































