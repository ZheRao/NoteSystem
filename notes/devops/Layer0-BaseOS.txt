

importnat syntax 

    - options and arguments 

        -  command -short_option_name arguments --long_options_name arguments
                short option names can be chained together, e.g., ls -lt : change to long format output, and sort the result by the file's modification time  


system information 
    - date & time
        -- date : display current time and date 
        -- cal : displays a calendar of the current month 
    - space & memory 
        -- df : current amount of free space on disk drives 
        -- free : dispaly the amount of free memory 


other notes

    - commands 

        -- 'tree' - shows the folder structure from your current directory downward

            --- example output 
                    .
                    ├── ETLPipeline
                    │   ├── Bronze
                    │   ├── Silver
                    │   └── Gold
                    └── README.md
            
            --- common options 
                    | Option       | Description                                         |         |
                    | ------------ | --------------------------------------------------- | ------- |
                    | `-L N`       | Limit depth to *N* levels (e.g., `tree -L 2`)       |         |
                    | `-d`         | Show only directories                               |         |
                    | `-f`         | Show full paths                                     |         |
                    | `-I pattern` | Ignore matching files/dirs (e.g., `-I "node_modules | .git"`) |
                    | `-a`         | Show hidden files (`.` prefix)                      |         |
                    | `-h`         | Show human-readable file sizes                      |         |
                    | `-C`         | Add color (usually on by default)                   |         |
            
            --- examples 
                ---- 'tree -L 3 -I "__pycache__|.git"' - prints up to 3 levels deep, skipping clutter 
                ---- 'tree -P "*.sh" -L 3' - locate shell scripts visually 

        -- 'rsync -av src/ dest/'
        
            --- copies files from 'src/' to 'dest/' efficiently, preserving metadata

            --- '-a' - archive mode (a bundle of options): recursive copy + preserve timestamps, perms, owner/group, symlinks, device, etc. 
                ---- (on WSL's '/mnt/c' some metadata can't be fully preserved - normal)

            --- '-v' - verbose output 

            --- important notes 
                ---- 'src/' with slash --> copy the contents of 'src' into 'dest'
                        -> result: 'dest/fileA', 'dest/subdir/...'
                ---- 'src' no slash --> copy the directory itself into 'dest'
                        -> result: 'dest/src/fileA', 'dest/src/subdir/...'

            --- typical usage 
                ---- 'rsync -av src/ dest/' - copy contents of src into dest (create dest if needed)
                ---- 'rsync -av --dry-run src/ dest/' - show what would happen (no change)
                ---- 'rsync -av --info=progress2 src/ dest/' - progress bar (handy for big trees)

            --- copy choices 
                ---- 'rsync -av src/file1 dest/' - copies file1 into dest/
                ---- 'rsync -av src/folder1/file1 dest/' - no original folder path - result: dest/file1 

            --- '--ignore-times'
                ---- by default, 'rsync' uses the "quick check" (same size & same modificiation time) to determine if two files are identical and should be skipped 
                ---- add this option disables the "quick skip" shortcut 
                        -> 'rsync' reads both files and computes rolloing checksums block by block - but only if the quick check would have skipped the file in the first place 
                        -> if both files' content hashes match, it will not overwrite
                        -> if not, 'rsync' will transfer only the changed parts

            --- '--checksum' 
                ---- compute checksums and send only when content actually differs (cost a tiny bit of CPU on both sides, fine for small JSON)
                ---- always computes and compare a full MD5-like checksum for every file, regardless of timstamp of size 
        
        -- 'wslpath -u "C:\Users\..."'
            --- portable, robust, and bi-directional 
            --- pattern 
            
                    # 1. Windows → Linux (use Linux tools on a Windows folder)
                    SRC_WIN='C:\Users\Zhe Rao\Documents\src'
                    SRC_LNX="$(wslpath -u "$SRC_WIN")"
                    rsync -av --info=progress2 "$SRC_LNX/" "$HOME/src_copy/"

                    # 2. Linux → Windows (call a Windows .exe on a Linux folder)
                    DST_LNX="$HOME\src_copy"
                    DST_WIN="$(wslpath -w "$DST_LNX")"
                    explorer.exe "$DST_WIN"

                    # 3. UNC share
                    UNC='\\fileserver\teamshare\project'
                    UNC_LNX="$(wslpath -u "$UNC")"   # -> /mnt/unc/fileserver/teamshare/project
                    ls "$UNC_LNX"


    
(single) file system tree 

    - 'pwd': display the current working directory

    - 'cd': change directory 

        -- 'cd /user/bin': absolute pathname 
        -- 'cd ..': relative pathname (change to the parent directory)
            --- 'cd ./bin': change to bin directory inside current working directory ('./' is implied, so usually just need to type cd bin)
        
        -- shortcuts  
            --- 'cd': change working directory to home directory 
            --- 'cd -': change working directory to the previous working directory 
            --- 'cd ~user_name': change working directory to the home directory of user_name 
    
    - 'ls': list files and directories 

        -- example usage 
            --- 'ls ~ /usr': list both the home directory (with ~) and the /usr directory 
            --- 'ls -l': change the output format (the long format) for more details 
            --- 'ls -lt --reverse': sort the result by the file's modification time, and reverse the order
        
        -- common options for ls 
        
                Option Long option          Description

                -a      --all               List all files, even those with names that begin with a period, which are normally not listed (that is, hidden).

                -A      --almost-all        Like the -a option except it does not list . (current directory) and .. (parent directory).

                -d      --directory         Ordinarily, if a directory is specified, ls will list the contents of the directory, not the directory itself. Use this
                                                    option in conjunction with the -l option to see details about the directory rather than its contents.

                -F      --classify          This option will append an indicator character to the end of each listed name. For example, it will append a
                                                    forward slash (/) if the name is a directory.

                -h      --human-readable    In long format listings, display file sizes in humanreadable format rather than in bytes.

                -l                          Display results in long format.
                
                -r      --reverse           Display the results in reverse order. Normally, ls displays its results in ascending alphabetical order.

                -S                          Sort results by file size.

                -t                          Sort by modification time.
        
        -- exmple of long format display  
                -rw-r--r--              1                   root                root                3576296         2017-04-03 11:05        Experience ubuntu.ogg
                access rights to file   # of hard links     name-file_owner     name-group_owner    size in bytes   time-last_modification  file_name

    - 'file file_name': display file's type  

    - 'less file_name': program that can view text files.
        
        -- why? 
            --- examine files that contain system settings (configuration files)
        
        -- commands 
                page up or b                        Scroll back one page
                page down or                        space Scroll forward one page
                Up arrow                            Scroll up one line
                Down arrow                          Scroll down one line
                G                                   Move to the end of the text file
                1G or g                             Move to the beginning of the text file
                /characters                         Search forward to the next occurrence of characters
                n                                   Search for the next occurrence of the previous search
                h                                   Display help screen
                q                                   Quit less

    - common directories 

                /                   The root directory, where everything begins.

                /bin                Contains binaries (programs) that must be present for the system to boot and run.

                /boot               Contains the Linux kernel, initial RAM disk image (for drivers needed at boot time), and the boot loader. Interesting files include /boot/
                                        grub/grub.conf, or menu.lst, which is used to configure the boot loader, and /boot/vmlinuz (or something similar), the Linux kernel.

                /dev                This is a special directory that contains device nodes. “Everything is a file” also applies to devices. Here is where the kernel maintains a list
                                        of all the devices it understands.

                /etc                The /etc directory contains all the system-wide configuration files. It also contains a collection of shell scripts that start each of the system
                                        services at boot time. Everything in this directory should be readable text. While everything in /etc is interesting, here are some all-time
                                        favorites: 
                                        -> /etc/crontab, a file that defines when automated jobs will run; 
                                        ->/etc/fstab, a table of storage devices and their associated mount points; and 
                                        -> /etc/passwd, a list of the user accounts.

                /home               In normal configurations, each user is given a directory in /home. Ordinary users can write files only in their home directories. This limitation
                                        protects the system from errant user activity.

                /lib                Contains shared library files used by the core system programs. These are similar to dynamic link libraries (DLLs) in Windows.

                /lost+found         Each formatted partition or device using a Linux file system, such as ext3, will have this directory. It is used in the case of a partial recovery
                                        from a file system corruption event. Unless something really bad has happened to your system, this directory will remain empty.
                                        
                /media              On modern Linux systems, the /media directory will contain the mount points for removable media such as USB drives, CD-ROMs,
                                        and so on, that are mounted automatically at insertion.

                /mnt                On older Linux systems, the /mnt directory contains mount points for removable devices that have been mounted manually.

                /opt                The /opt directory is used to install “optional” software. This is mainly used to hold commercial software products that might be installed on
                                        the system.

                /proc               The /proc directory is special. It’s not a real file system in the sense of files stored on your hard drive. Rather, it is a virtual file system maintained
                                        by the Linux kernel. The “files” it contains are peepholes into the kernel itself. The files are readable and will give you a picture of
                                        how the kernel sees your computer.
                                    
                /root               This is the home directory for the root account.

                /sbin               This directory contains “system” binaries. These are programs that perform vital system tasks that are generally reserved for the superuser.

                /tmp                The /tmp directory is intended for the storage of temporary, transient files created by various programs. Some configurations cause this
                                        directory to be emptied each time the system is rebooted.

                /usr                The /usr directory tree is likely the largest one on a Linux system. It contains all the programs and support files used by regular users.

                /usr/bin            /usr/bin contains the executable programs installed by your Linux distribution. It is not uncommon for this directory to hold thousands of programs.

                /usr/lib            The shared libraries for the programs in /usr/bin.

                /usr/local          The /usr/local tree is where programs that are not included with your distribution but are intended for system-wide use are installed.
                                        Programs compiled from source code are normally installed in /usr/local/bin. On a newly installed Linux system, this tree exists, but it will
                                        be empty until the system administrator puts something in it.

                /usr/sbin           Contains more system administration programs.

                /usr/share          /usr/share contains all the shared data used by programs in /usr/bin. This includes things such as default configuration files, icons, screen
                                        backgrounds, sound files, and so on.

                /usr/share/doc      Most packages installed on the system will include some kind of documentation. In /usr/share/doc, we will find documentation files organized by package.

                /var                With the exception of /tmp and /home, the directories we have looked at so far remain relatively static; that is, their contents don’t
                                        change. The /var directory tree is where data that is likely to change is stored. Various databases, spool files, user mail, and so forth, are
                                        located here.

                /var/log            /var/log contains log files, records of various system activity. These are important and should be monitored from time to time. The most
                                        useful ones are /var/log/messages and /var/log/syslog. Note that for security reasons on some systems, you must be the superuser to
                                        view log files.
    
    - links 
        -- symbolic/soft link : file referenced by multiple names 
            
            --- 'lrwxrwxrwx 1 root root 11 2018-08-11 07:34 libc.so.6 -> libc-2.6.so'
                ---- programs looking for 'libc.so.6' will get the file 'libc-2.6.so'
        
        -- hard link : allows files to have multiple names in a different way 


manipulating files and directories 

    - wildcards: special characters that can help you rapidly specify groups of filenames

            *                                   Matches any characters

            ?                                   Matches any single character

            [characters]                        Matches any character that is a member of the set characters

            [!characters]                       Matches any character that is not a member of the set characters

            [[:class:]]                         Matches any character that is a member of the specified class

            [:alnum:]                           Matches any alphanumeric character

            [:alpha:]                           Matches any alphabetic character

            [:digit:]                           Matches any numeral

            [:lower:]                           Matches any lowercase letter

            [:upper:]                           Matches any uppercase letter
        
        -- examples 
            
            *                           All files

            g*                          Any file beginning with g

            b*.txt                      Any file beginning with b followed by any characters and ending with .txt

            Data???                     Any file beginning with Data followed by exactly three characters

            [abc]*                      Any file beginning with either an 'a', a 'b', or a 'c'

            BACKUP.[0-9][0-9][0-9]      Any file beginning with 'BACKUP.' followed by exactly three numerals

            [[:upper:]]*                Any file beginning with an uppercase letter

            [![:digit:]]*               Any file not beginning with a numeral

            *[[:lower:]123]             Any file ending with a lowercase letter or the numerals 1, 2, or 3
    
    - 'mkdir dir1 dir2 dir3 ... ': make new directories 

    - 'cp': copy files 

        -- 'cp item1 item2': copies single file or directory item1, to the file or directory item2 

        -- 'cp item... directory': copies multiple items (either files or directories) into a directory 

        -- common options 

                -a, --archive           Copy the files and directories and all of their attributes, including ownerships and permissions. Normally, copies take on the default
                                            attributes of the user performing the copy. We’ll take a look at file permissions in Chapter 9.

                -i, --interactive       Before overwriting an existing file, prompt the user for confirmation. If this option is not specified, cp will silently (meaning there
                                            will be no warning) overwrite files.

                -r, --recursive         Recursively copy directories and their contents. This option (or the -a option) is required when copying directories.

                -u, --update            When copying files from one directory to another, only copy files that either don’t exist or are newer than the existing corresponding
                                            files in the destination directory. This is useful when copying large numbers of files as it skips files that don’t need to be copied.

                -v, --verbose           Display informative messages as the copy is performed.
        
        -- examples 

                cp file1 file2                  Copy file1 to file2. If file2 exists, it is overwritten with the contents of file1. If file2 does not exist, it is created.

                cp -i file1 file2               Same as previous command, except that if file2 exists, the user is prompted before it is overwritten.

                cp file1 file2 dir1             Copy file1 and file2 into directory dir1. The directory dir1 must already exist.

                cp dir1/* dir2                  Using a wildcard, copy all the files in dir1 into dir2. The directory dir2 must already exist.

                cp -r dir1 dir2                 Copy the contents of directory dir1 to directory dir2. If directory dir2 does not exist, it is created and, after the copy, 
                                                    will contain the same contents as directory dir1. If directory dir2 does exist, then directory dir1 (and its contents) 
                                                    will be copied into dir2.
    
    - 'mv': move and rename files 

        -- 'mv item1 item2': move or rename the file or directory item1 to item2 

        -- 'mv item... directory': move one or more items from one directory to another 

        -- options 

                -i, --interactive       Before overwriting an existing file, prompt the user for confirmation. If this option is not specified, mv will silently overwrite files.

                -u, --update            When moving files from one directory to another, only move files that either don’t exist or are newer than the existing corresponding
                                            files in the destination directory.

                -v, --verbose           Display informative messages as the move is performed.
        
        -- examples 

                mv file1 file2          Move file1 to file2. If file2 exists, it is overwritten with the contents of file1. If file2 does not exist, 
                                            it is created. In either case, file1 ceases to exist.

                mv -i file1 file2       Same as the previous command, except that if file2 exists, the user is prompted before it is overwritten.

                mv file1 file2 dir1     Move file1 and file2 into directory dir1. The directory dir1 must already exist.

                mv dir1 dir2            If directory dir2 does not exist, create directory dir2 and move the contents of directory dir1 into dir2 and delete directory dir1.
                                            If directory dir2 does exist, move directory dir1 (and its contents) into directory dir2.
    
    - 'rm': remove files and directories 

        -- 'rm item...': item is one or more files or directories, note: delete with rm, it's gone for good 
                            good practice: before rm with wildcards, use ls to examine if the files are intended to be deleted, then change ls with rm

        -- options 

                -i, --interactive       Before deleting an existing file, prompt the user for confirmation. If this option is not specified, rm will silently delete files.

                -r, --recursive         Recursively delete directories. This means that if a directory being deleted has subdirectories, delete them too. To delete a
                                            directory, this option must be specified.

                -f, --force             Ignore nonexistent files and do not prompt. This overrides the --interactive option.

                -v, --verbose           Display informative messages as the deletion is performed.
        
        -- examples 

                rm file1        Delete file1 silently.

                rm -i           file1 Same as the previous command, except that the user is prompted for confirmation before the deletion is performed.

                rm -r           file1 dir1 Delete file1 and dir1 and its contents.

                rm -rf          file1 dir1 Same as the previous command, except that if either file1 or dir1 does not exist, rm will continue silently.
    
    - 'ln': create either hard or symbolic links 

        -- 'ln file link': creates a hard link 
            --- by default, every file has a single hard link that gives the file its name 
            --- when we create a hard link, we create an additional directory entry for a file.
            --- hard links have two importnat limitations: 
                ---- cannot reference a file outside its own file system (not on the same disk partition) 
                ---- cannot reference a directory
            --- a hard link is indistinguishable for the file itself. there's no special indiciation of the link 
            --- modern practice prefers symbolic links
            --- to see whether two differnt file names are pointing at the same file, use 'ls -i' and check whether the first number is the same 
            --- when creating hard links, we are actually creating additional name parts that all refer to the same data part 
                ---- the system assigns a chain of disk blocks to what is called an 'inode', which is then associated with the different names 
                ---- each hard link therefore refers to a specific inode containing the file's contents 

        -- 'ln -s item (:actual_file) link (:link_name)' : creates a symbolic link, where item is either a file or a directory 
            --- created to overcome limitations of hard links 
            --- it creates a special type of file that contains a text pointer to the referenced file or directory (like Windows Shortcut)
            --- if you write something to the symbolic link, reference file is written to 
            --- when delete a symbolic link, only the link is deleted, not the file. 
            --- if the file is deleted before the symbolic link, the link will just point at nothing, broken links are displayed in red with 'ls'
            --- when creating a symbolic link, you can either use absolute pathnames, or relative path names
            --- when create a symlink, the path you give (item) is stored exactly as typed 
                ---- if the path is a relative path, it is interpreted from the location of the symlink itself 
        
        -- examples : hard link
                
                file structure
                    └── dir1 
                    └── dir2
                    └── fun 
                
                -> ln fun fun-hard
                -> ln fun dir1/fun-hard
                -> ln fun dir2/fun-hard
                -> there are now 4 instances of the same file, running 'ls -li' returns 
                    12353539 drwxrwxr-x 2 me me 4096 2018-01-14 16:17 dir1
                    12353540 drwxrwxr-x 2 me me 4096 2018-01-14 16:17 dir2
                    12353538 -rw-r--r-- 4 me me 1650 2018-01-10 16:33 fun
                    12353538 -rw-r--r-- 4 me me 1650 2018-01-10 16:33 fun-hard
                    
        -- examples : symbolic links (inside dir1)

                -> ln -s fun fun-sym
                -> ln -s ../fun dir1/fun-sym
                    --> a file 'dir1/fun-sysm' that points to '../fun', when accesss 'dir1/fun-sym', system resolves it from inside 'dir1' 
                -> ln -s ../fun dir2/fun-sym
                -> note that here uses relative location, relatively to inside dir1, fun is in the directory above it, if we run 'ls -l dir1'
                    -rw-r--r-- 4 me me 1650 2018-01-10 16:33 fun-hard
                    lrwxrwxrwx 1 me me 6 2018-01-15 15:17 fun-sym -> ../fun
                -> and we can also reference directory: 'ln -s dir1 dir1-sym' and run 'ls -l' returns 
                    drwxrwxr-x 2 me me 4096 2018-01-15 15:17 dir1
                    lrwxrwxrwx 1 me me 4 2018-01-16 14:45 dir1-sym -> dir1
                    drwxrwxr-x 2 me me 4096 2018-01-15 15:17 dir2
                    -rw-r--r-- 4 me me 1650 2018-01-10 16:33 fun
                    -rw-r--r-- 4 me me 1650 2018-01-10 16:33 fun-hard
                    lrwxrwxrwx 1 me me 3 2018-01-15 15:15 fun-sym -> fun


working with commands 

    - 'type': display a command's type 

        -- examples 
            [me@linuxbox ~]$ type type
            type is a shell builtin
            [me@linuxbox ~]$ type ls
            ls is aliased to `ls --color=tty'
            [me@linuxbox ~]$ type cp
            cp is /bin/cp
    
    - 'which': display an executable's location 

        -- motivation
            --- there could be more than one version of an executable program installed on a system 
            --- 'which' can be used to determine the exact location of a given executable

        -- example 
                [me@linuxbox ~]$ which ls
                /bin/ls
        
        -- 'which' works only for executable programs, not builtins or aliases that are substitutes for actual executable programs 

    - 'help': get help for shell builtins

        -- 'help cd'
                cd: cd [-L|[-P [-e]] [-@]] [dir]
                    Change the shell working directory.
                    ...
                    Options:
                
            --- note that cd [-L|[-P[-e]]] [dir] means cd may be followed by either -L or a -P, and if -P is specified, -e may also be used 
        
        -- '--help': display usgage information
            --- many executable programs support a --help option that displays a description of the command's supported syntax and options.
            --- e.g., mkdir --help 
                ---- Usage: mkdir [OPTION] DIRECTORY...
                ---- Create the DIRECTORY(ies), if they do not already exist.
                        -Z, --context=CONTEXT (SELinux) ...
    
    - 'man': display a program's manual page 

        -- 'man' can be used to dispaly manual pages for commands 
            --- 'man ls'
            --- it uses 'less' to display the manual page 
        
        -- 'man' can also be used to display system administration commands, programming interfaces, file formats, and more, below lists sections that it can display 
                1   User commands
                2   Programming interfaces for kernel system calls
                3   Programming interfaces to the C library
                4   Special files such as device nodes and drivers
                5   File formats
                6   Games and amusements such as screen savers
                7   Miscellaneous
                8   System administration commands
            
            --- syntax: 'man section search_term'
            --- 'man 5 passwd': this will display the man page describing the file format of the /etc/passwd file 

    - 'apropos': display appropriate commands 

        -- it is possible to search the list of man pages for possible matches based on a search term 

        -- 'apropos partition' 
                addpart (8)             - simple wrapper around the 'add partition' ioctl
                all-swaps (7)           - event signalling that all swap partitions have been ac...
                cfdisk (8)              - display or manipulate disk partition table
                cgdisk (8)              - Curses-based GUID partition table (GPT) manipulator
                delpart (8)             - simple wrapper around the 'del partition' ioctl
                fdisk (8)               - manipulate disk partition table
                fixparts (8)            - MBR partition table repair utility
                gdisk (8)               - Interactive GUID partition table (GPT) manipulator
                mpartition (1)          - partition an MSDOS hard disk
                partprobe (8)           - inform the OS of partition table changes
                partx (8)               - tell the Linux kernel about the presence and numbering...
                resizepart (8)          - simple wrapper around the 'resize partition' ioctl
                sfdisk (8)              - partition table manipulator for Linux
                sgdisk (8)              - Command-line GUID partition table (GPT) manipulator fo..
            
            -> first field is the name of the man page, second field shows the section 
            -> 'man -k' performs the same function as 'apropos'
    
    - 'whatis': display one-line manual page descriptions 

        -- whatis ls 
                ls (1)       list directory contents
    
    - 'info': display a program's info entry 

        -- the 'info' program reads info files, which are tree structured into individual nodes, each ontaining a single topic 

        -- info files contain hyperlinks that can move you from node to node 

        -- many software packages installed have documentation files residing in the /usr/share/doc directory 
    
    - 'alias': creating commands with alias

        -- it's possible to chain command together with ;
            --- cd /user; ls; cd -
                    bin games include lib local sbin share src
                    /home/me
                    [me@linuxbox ~]$
        
        -- 'type': we can find out whether a name is already being used for alias with 'type'
            --- 'type test'
                    test is a shell builtin
                    it's already been used 
                
            --- 'type foo' 
                    bash: type: foo: not found
                    we can use this one as alias 
        
        -- 'alias': create alias with structure : alias name='command string'
            --- alias foo='cd /user; ls; cd -'
            --- foo 
                    bin games include lib local sbin share src
                    /home/me
                    [me@linuxbox ~]$
            --- type foo 
                    foo is aliased to `cd /usr; ls; cd -'
        
        -- 'unalias': remove an alias 

        -- 'alias': see all the aliases defined in the environment with 'alias' without arguments 
            --- alias 
                    alias l.='ls -d .* --color=tty'
                    alias ll='ls -l --color=tty'
                    alias ls='ls --color=tty'
        
        -- alias vanish when shell session ends, but we can add aliases to the files that establish the environment


I/O redirection : redirecting the input and output of commands 

    - 'stdin', 'stdout', 'stderr': standard input, output, and error 

        -- programs produce outputs of two kinds 

            --- program's results, i.e., data the program is deisnged to produce 
                ---- results are sent to a special file called standard output ('stdout')

            --- status and error message, tells us how the program is getting along 
                ---- status messages are sent to another file called standard error ('stderr')

            --- by default, those two files are linked to the screen and bot saved into a disk file 
        
        -- many programs take input from a facility called standard input ('stdin')
            --- this is attached to the keyboard 
        
        -- I/O redirection allows us to change where output goes and where input comes from.
    
    - redirecting standard output & error 

        -- '>' - (create or overwrite output file)
            --- 'ls -l /usr/bin > ls-output.txt' 
                ---- create a listing of the /user/bin directory and sent the results to the file 'ls-output.txt'
                ---- it cannot redirect error messages, so if /user/bin doesn't exist, nothing will be written in 'ls-output.txt'
            --- '>>' - (create or append output file)

        -- '2>' - file descriptor for standard error 
            --- 'ls -l /bin/usr 2> ls-error.txt'

        -- '&>' - redirect both output and error 
            
            --- 'ls -l /bin/usr &> ls-output.txt'
                -> redirect both output and error to the file 'ls-output.txt'
                -> use '&>>' for append 
            
            --- older-version: the redirection of stderr must always occur after redirecting stdout or it doesn't work 
                ---- for example, the following command redirects stderr to the file 'ls-output.txt'
                        -> '>ls-output.txt 2>&1'
                ---- but changing the order will result in stderr directed to the screen 
                        -> '2>&1 >ls-output.txt'
    
        -- '/dev/null': disposing output - throw away output from a command - "silence is golden" - not output will ever be printed
            --- 'ls -l /bin/usr 2> /dev/null'
            --- '/dev/null' is a system device often referred to as a bit bucket, which accepts input and does nothing with it
    
    - redirecting standard input

        -- 'cat': concatenate files - reads one or more files and copies them to standard output 

            --- 'cat ls-output.txt'
                ---- analogous to the 'type' command. Display files without paging.

            --- 'cat movie.mpeg.0* > movie.mpeg' 
                ---- we can merge multiple files and store them into a single file with this command

            --- 'cat' without arguments reads from standard input (keyboard)
                ---- it copies standard input to standard output 
                ---- after typing + ENTER + CTRL+D (EOF), it will output whatever we typed

            --- 'cat > lazy_dog.txt'
                ---- redircting keyboard input into a txt file 
                ---- don't forget to type CTRL+D at the end 
            
            --- 'cat lazy_dog.txt'
                ---- we can use 'cat' to copy the file to stdout again for see our results
            
            --- 'cat < lazy_dog.txt'
                ---- with '<' we change the source of stdin from the keyboard to the file 'lazy_dog.txt'
                ---- the result is the same as passing a single filename argument
    
    - '|': pipelines

            -- concept 
                --- the capability of commands to read data from stdin and send to stdout is utilized by a shell feature called 'pipeline'
                --- with '|', the stdout of one command can be piped into the stdin of another 

            -- example: 'ls -l /usr/bin | less'
                --- 'less' accepts standard input 
                --- we can use less to display, page by page, the output of any command that sends its results to standard output 
            
            -- '|' vs. '>'
                --- '>' connects a command with a file - silently creates or overwrites files 
                    ---- 'ls > less' is catastrophic because it could overwrite the 'less' program file with the text from ls 
                    ---- if you are in directory '/usr/bin' that contains a file named 'less' (the 'less' program)
            
            -- filters 

                -- filters take input, change it somehow, and then output it

                --- 'sort': sort input
                    ---- example: 'ls /bin /usr/bin | sort | less'
                    ---- this makes a combined list of all the executable programs in /bin and /usr/bin, put them in sorted order and view the rsults 
                    ---- by including 'sort', it produces a single, sorted list 
    
                --- 'uniq': report or omit repeated lines 
                    ---- example: 'ls /bin /usr/bin | sort | uniq | less'
                    ---- unique accepts a sorted list of data from standard input or a single filename argument, and remove duplicated items 
                    ---- use 'uniq -d' to see the list of duplicates instead 
                
                --- 'wc': print line, world, and byte counts 
                    ---- example: 'wc ls-output.txt'
                    ---- print lines, words, and bytes contained in ls-output.txt 
                            -> 7902 64566 503634 ls-output.txt
                    ---- if execute without arguments, it accepts standard input 
                    ---- '-l' option limits its output to report only lines 
                    ---- to see the number of items we have in our sorted list, we can do this 
                            -> [me@linuxbox ~]$ ls /bin /usr/bin | sort | uniq | wc -l
                                2728
            
                --- 'grep _pattern _filename': printlines matching a pattern 
                    ---- example: 'ls /bin /usr/bin | sort | uniq | grep zip'
                    ---- find all the files in our list of programs that had the word 'zip' embedded in the name.
                    ---- '-i' : ignore case 
                    ---- '-v' : print only those lines that do not match the pattern 
                
                --- 'head'/'tail': print first/last part of files
                    ---- example: 'head -n 5 ls-output.txt'
                    ---- default print first/last 10 lines, adjusted with '-n' option 
                    ---- in pipeline: 'ls /usr/bin | tail -n 5'
                    ---- tail -f /var/log/messages
                            -> '-f' options allows 'tail' continuing to monitor the file, and when new lines are appended, they immediately appear in the dispaly
                            -> CTRL+C breaks it 
                            -> superuser privileges are required 
                
                --- 'tee': read from 'stdin' and output to 'stdout' and files
                    ---- example, 'ls /usr/bin | tee ls.txt | grep zip'
                    ---- 'tee ls.txt' creates a complete list of /usr/bin from 'ls /usr/bin' and store it in ls.txt, and continue the pipeline 
                    ---- 'tee' allows the previous output to 
                            -> be stored in a file and 
                            -> pass through to the next stage in the pipeline 


seeing the world as the shell sees it 

    - '$': introduces some kind of expansion or substitution 

        -- before executing a command, everything that follows '$' is the shell's signal to 
            --- "look something up"
            --- "compute something"
            --- "replace something with a value"
        
        -- the shell operates in two phases
            --- parse and expand everything 
            --- execute the resulting command 
        
        -- '$' neveer means "variable" by itself - it means "evaluate/expand something here"
            | Syntax            | Name                                    | What it does                              | Example                     | Result          |
            | ----------------- | --------------------------------------- | ----------------------------------------- | --------------------------- | --------------- |
            | `$VAR` / `${VAR}` | **Parameter (variable) expansion**      | Replaces with variable’s value            | `echo $HOME`                | `/home/zhe_rao` |
            | `$((…))`          | **Arithmetic expansion**                | Evaluates an integer expression           | `echo $((2+3))`             | `5`             |
            | `$(…)`            | **Command substitution**                | Runs a command and substitutes its output | `echo $(date +%Y)`          | `2025`          |
            | `${VAR:-default}` | **Parameter substitution with default** | Use default if unset                      | `echo ${x:-42}`             | `42`            |
            | `$*` / `$@`       | **Positional parameters**               | All script arguments                      | in script: `$1`, `$2`, etc. |                 |
            | `$#`              | **Number of arguments**                 | Counts positional parameters              | `echo $#`                   | `3`             |
            | `$?`              | **Exit status**                         | Last command’s exit code                  | `echo $?`                   | `0` if success  |
            | `$$`              | **Current PID**                         | Process ID of the shell                   | `echo $$`                   | `7264`          |
            | `$!`              | **PID of last background job**          | Useful for tracking background tasks      |                             |                 |
            | `$0`              | **Script name**                         | The command or script that was run        |                             |                 |

    - expansion: before 'bash' carries out commands, it performs several substitutions upon the text

        -- how "pattern matcher" works?

            --- 'echo *.sh'
                ---- the shell, not the filesystem, sees '*'
                ---- it checks "is there any unquoted wildcard character in this argument?"
                ---- if yes -> perform "pathname expansion" (also called "globbing")
                ---- it scans the current directory's entires (names only - not file contents)
                ---- it tests each name against the pattern '*.sh'
                ---- all matches are substituted into the command line before execution

            --- how the matching itself works 
                ---- at a high level, the shell uses a library routine like 'glob()' (in C, from '<glob.h>')
                ---- it iterates through directory entries returned by 'opendir()' / 'readdir()' and applies pattern rules

        -- 'echo': prints text arguments on stdout - can be used to examine expansions 

            --- example: 'echo *' -> Desktop Documents ls-output.txt Music ...
            
            --- why didn't 'echo' print '*'?
                ---- '*' character means match any character in a filename 
                ---- before executing anything, '*' was expanded into the names of the files in the current working directory
                ---- when the ENTER key is pressed, the shell automatically expands any qulifying char on the command line before the command is carried out 
                ---- so the 'echo' command never saw the '*', only its expanded results
        
        -- pathname expansion: the mechanism by which wildcards work 

            --- examples 
                ---- 'echo D*' -> Desktop Documents 
                ---- 'echo *s' -> Documents Pictures Templates Videos 
                ---- 'echo [[:upper:]]*' -> Desktop Documents Music Pictures Public Templates Videos 
                ---- 'echo /usr/*/share' -> /usr/kerberos/share /usr/local/share 
            
            --- hidden files 
                ---- 'echo .*' -> almost correct, will include names "." (current working directory) and ".." (parent directory)
                ---- 'echo .[!.]*' -> filenames that begins with only one period followed by any other characters - wouldn't include filenames with multiple leading periods 
        
        -- tilde ('~') expansion

            --- when '~' is used at the beginning of a word: it expands into the name of the home directory of the named/current user
                ---- 'echo ~' -> /home/me 
                ---- 'echo ~foo' -> /home/foo 
        
        -- arithmetic expansion 

            --- shell allows arithmetic performed by expansion 
                ---- 'echo $((2+2))' -> 4 
            
            --- under the hood 
                ---- '$()' -> "expand this expression - replace it with its result"
                        -> alreayd had a meaning before arithmetic expansion was invented 
                        -> '$()' originally meant command substituion 
                ---- inner '(...)' -> encloses the arithmetic expression itself 
            
            --- caution
                ---- arithmetic expansion supports only integers 
                ---- spaces are not significant 
                ---- expressions may be nested 
                ---- integer division is rounded 
                        -> '$((5/2))' -> 2 
                        -> '$((5%2))' -> 1
            
            --- operators supported 
                ---- +, -, *, /, %, ** (exponents)
        
        -- brace expansion

            --- create multiple text strings from a pattern containing braces 
                ---- 'echo Front-{A,B,C}-Back' -> Front-A-Back Front-B-Back Front-C-Back
                ---- brace expansions may be nested
            
            --- brace structure 
                ---- may contain a leading portion called a "preamble" and a trailing portion called a "postcript"
                ---- may contain either a 
                        -> comma-separated list of strings or 
                        -> range of integers

            --- examples 
                ---- 'echo Number_{1..5}' -> Number_1 Number_2 Number_3 Number_4 Number_5
                ---- 'echo {001..15}' -> 001 002 003 004 005 006 007 008 009 010 011 012 013 014 015
                ---- 'echo {Z..A}' -> Z Y X W V U T S R Q P O N M L K J I H G F E D C B A
                ---- 'echo a{A{1,2},B{3,4}}b' -> aA1b aA2b aB3b aB4b
            
            --- caution
                ---- pattern inside brace expansion cannot contain unquoted whitespace 
            
            --- practical application: specific targeted list of file names 
                --- 'mkdir {2007..2009}-{01..12}'
                --- ls
                    2007-01 2007-07 2008-01 2008-07 2009-01 2009-07
                    2007-02 2007-08 2008-02 2008-08 2009-02 2009-08
                    2007-03 2007-09 2008-03 2008-09 2009-03 2009-09
                    2007-04 2007-10 2008-04 2008-10 2009-04 2009-10
                    2007-05 2007-11 2008-05 2008-11 2009-05 2009-11
                    2007-06 2007-12 2008-06 2008-12 2009-06 2009-12
        
        -- parameter expansion 

            --- this is more useful in shell scripting than directly on the command line - details covered later 

            --- concept 
                ---- have to do with the system's ability to store small chunks of data and to give each chunk a name 
                ---- many such chunks, more properly called "variables", are available for examination 
                ---- e.g., 'USER' variable contains your username 
            
            --- use '$' to invoke parameter expansion 
                ---- 'printenv | less' - to see a list of available variables 

            --- caution
                ---- if you mistype a pattern in other types of expansion, 'echo' simply display the mistyped pattern 
                ---- if you misspell the variable name, the expansion will still take place but will result in an empty string 

        -- command substitution 

            --- '$()': allows us to use the output of a command as an expansion 

            --- examples 
                ---- 'echo $(ls)' -> Desktop Documents ls-output.txt Music Pictures Public Templates Videos
                ---- 'ls -l $(which cp)'
                        -> we passed the results of 'which cp' as an argument to the 'ls' command 
                        -> getting the listing of the 'cp' program without having to know its full pathname 
            
            --- alternate syntax for command substitution in older shell programs - with backquote
                ---- 'ls -l `which cp`'

    - quoting 

        -- behaviors without quoting 

            --- 'echo this is a      test' -> this is a test 
                ---- "world splitting" by the shell removed extra whitespace from the 'echo' command's list of arguments 

            --- 'echo The total is $100.00' -> The total is 00.00
                ---- parameter expansion substituted an empty string for the value of '$1' because it was an undefined variable 

        -- double quotes 

            --- behavior 
                ---- all the special characters used by the shell lose their speical meaning and are treated as ordinary characters 
                ---- word splitting, pathname expansion, tilde expansion, and brace expansion are suppressed
                ---- parameter expansion, arithmetic expansion, and command substitution are still carred out 

            --- exceptions 
                ---- $ (dollar sign)
                ---- \ (backslash) 
                ---- ` (backtick) 
            
            --- examine effect on command substitution 

                ---- word splitting looks for presence of spaces, tabs, and newlines and treats them as "delimiters" between words 
                        -> unquoted spaces, tabs, and newlines are not considered to be part of the text, they serve only as separators 
                        -> with double quotes, word splitting is supressed and the embeded spaces are not treated as delimiter - they become part of the argument 
                
                ---- 'echo $(cal)' vs. 'echo "$(cal)"'
                        -> the unquoted command substitution resulted in a command line containing 38 arguments 
                                February 2020 Su Mo Tu We Th Fr Sa 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17
                                18 19 20 21 22 23 24 25 26 27 28 29
                        -> the second resulted in a command line with one argument that includes the embedded spaces and newlines 
                                February 2020
                                Su Mo Tu We Th Fr Sa
                                1
                                2 3 4 5 6 7 8
                                9 10 11 12 13 14 15
                                16 17 18 19 20 21 22
                                23 24 25 26 27 28 29
        
        -- single quotes 

            --- single quotes suppress all expansions 
        
    - '\': escaping characters 

        -- use cases 

            --- selectively prevent an expansion 
                ---- echo "The balance for user $USER is: \$5.00" -> The balance for user me is: $5.00
            
            --- eliminate the special meaning of a character in a filename 
                ---- include $, !, &, space, and others 
                ---- 'mv bad\$filename good_filename'
            
        -- to allow a backslash character to appear, escape it by typing '\\'

        -- note that backslash loses its special meaning and is treated as an ordinary character within single quotes 

        -- backslash escape sequence 
            
            --- backslash is also used as part of a notation to represent certain special characters called "control codes"

            --- examples 
                
                \a      Bell (an alert that causes the computer to beep)
                \b      Backspace
                \n      Newline; on Unix-like systems, this produces a line feed
                \r      Carriage return
                \t      Tab
    
            --- adding the '-e' option to 'echo' will enable interpretation of escape sequences
                ---- can also place them inside $' '
                ---- echo -e "Time's up\a"
                ---- echo "Time's up" $'\a'


advance keyboard tricks

    - 'readline': bash uses this library to implement command line editing 

        -- cursor movement 

                ctrl-A              Move cursor to the beginning of the line.
                ctrl-E              Move cursor to the end of the line.
                ctrl-F              Move cursor forward one character; same as the right arrow key.
                ctrl-B              Move cursor backward one character; same as the left arrow key.
                alt-F               Move cursor forward one word.
                alt-B               Move cursor backward one word.
                ctrl-L              Clear the screen and move the cursor to the top-left corner. The clear
                                        command does the same thing.
        
        -- modifying text 

                ctrl-D              Delete the character at the cursor location.
                ctrl-T              Transpose (exchange) the character at the cursor location with the one preceding it.
                alt-T               Transpose the word at the cursor location with the one preceding it.
                alt-L               Convert the characters from the cursor location to the end of the word to lowercase.
                alt-U               Convert the characters from the cursor location to the end of the word to uppercase.
        
        -- cutting and pasting (killing and yanking) text 

                ctrl-K              Kill text from the cursor location to the end of line.
                ctrl-U              Kill text from the cursor location to the beginning of the line.
                alt-D               Kill text from the cursor location to the end of the current word.
                alt-backspace       Kill text from the cursor location to the beginning of the current word. If
                                        the cursor is at the beginning of a word, kill the previous word.
                ctrl-Y              Yank text from the kill-ring and insert it at the cursor location.
        
        -- TAB : completion 

                -> [me@linuxbox ~]$ ls
                    Desktop ls-output.txt Pictures Templates Videos
                    Documents Music Public
                
                -> [me@linuxbox ~]$ ls l    + TAB   =    [me@linuxbox ~]$ ls ls-output.txt
                    --> when there's no completion when the letter(s) entered matches more than one entry in the directory 
                    --> for the completion to work, the 'clue' must be unambiguous 
                
                -> completion works on 
                    --> pathnames 
                    --> variables (word begins with '$')
                    --> usernames (word begins with '~')
                    --> commands (word is the first word on the line)
                    --> hostnames (word begins with '@')
                        ---> only works for hostnames listed in /etc/hosts 

                -> controls 
                    alt-?           Display a list of possible completions. On most systems, you can also
                                        do this by pressing the tab key a second time, which is much easier.
                    alt-*           Insert all possible completions. This is useful when you want to use more
                                        than one possible match.
        
        -- history

                -> histories commands are kept in the home directory in a file called bash_history

                -> searching history 
                    --> [me@linuxbox ~]$ history | less
                    --> [me@linuxbox ~]$ history | grep /usr/bin
                        ---> find the commands we used to list /usr/bin 
                        ---> results will contain the line number of the command in the history list 
                    --> [me@linuxbox ~]$ !line_num 
                        ---> history expansion 
                    
                -> incremental search (reverse-i-search)
                    --> press CTRL+R to start typing 
                    --> press ENTER to execute command when found 
                    --> or press CTRL-J to copy the line from the history list to the current command line 
                    --> press CTRL+R again to find the next occurrence 
                
                -> history commands 
                    ctrl-P          Move to the previous history entry. This is the same action as the up arrow.
                    ctrl-N          Move to the next history entry. This is the same action as the down arrow.
                    alt-<           Move to the beginning (top) of the history list.
                    alt->           Move to the end (bottom) of the history list, i.e., the current command line.
                    ctrl-R          Reverse incremental search. This searches incrementally from the current command line up the history list.
                    alt-P           Reverse search, nonincremental. With this key, type in the search string and press enter before the search is performed.
                    alt-N           Forward search, nonincremental.
                    ctrl-O          Execute the current item in the history list and advance to the next one. This
                                        is handy if you are trying to re-execute a sequence of commands in the history list.
                
                -> history expansion 
                    !!              Repeat the last command. It is probably easier to press the up arrow and enter.
                    !number         Repeat history list item number.
                    !string         Repeat last history list item starting with string.
                    !?string        Repeat last history list item containing string.
    
        -- script file_name : record the shell session and store it in file_name

            -> if no file is specified, the file 'typescript' is used


permissions 

    - Linux systems are designed for multi-users 
        -- remote users can log in via 'ssh' (secure shell) and operate the computer 
        -- there is a method that protect users from each other

    - roles 

        -- owners: a user may own files and directories, that user then has control over its access 

        -- group: users can beong to a group consisting of one or more users who are given access to files and directories by the owner 

        -- world: owner may also grant some set of access rights to everybody, in Unix is referred to as the world 

        -- id: find information about identity
                ->  [me@linuxbox ~]$ id
                    uid=500(me) gid=500(me) groups=500(me)
                    
                    --> when user accounts are created, users are assigned a number called a user ID (uid) 
                    --> the user is assigned a group ID (gid) and may belong to adidtional groups 
        
        -- storage of identity information 

                -> user accounts are defined in the '/etc/passwd' file, and groups are defined in the '/etc/group' file 
                    --> when the accounts are created, files are modified along with 'etc/shadow' which holds user's password information 

                -> for each user account, the /etc/passwd defines 
                    --> user (login) name, uid, gid
                    --> account's real name, home directory, and login shell 

    - access : reading, writing, and executing 

        --  [me@linuxbox ~]$ ls -l foo.txt
                -rw-rw-r-- 1 me me 0 2018-03-06 14:52 foo.txt

                -> the first 10 characters are the file attributes, which defines 

                    --> 1st char : files types
                        ---> common examples

                                -           A regular file.
                                d           A directory.
                                l           A symbolic link. Notice that with symbolic links, the remaining file attributes are always rwxrwxrwx and are dummy values. 
                                                The real file attributes are those of the file the symbolic link points to.
                                c           A character special file. This file type refers to a device that handles data
                                                as a stream of bytes, such as a terminal or /dev/null.
                                b           A block special file. This file type refers to a device that handles data in
                                                blocks, such as a hard drive or DVD drive.
                    
                    --> remining chars : file mode : listed in the order of perssions of 1. file's owner, 2. file's group owner, and everyone else 

                        ---> definition of permissions

                            attribute   files                                               directories 
                                r       Allows a file to be opened and read.                Allows a directory’s contents to
                                                                                                be listed if the execute attribute is also set.

                                w       Allows a file to be written to or                   Allows files within a directory to be
                                            truncated; however, this attribute                  created, deleted, and renamed if
                                            does not allow files to be renamed                  the execute attribute is also set.
                                            or deleted. The ability to delete or
                                            rename files is determined by directory
                                            attributes.

                                x       Allows a file to be treated as a                    Allows a directory to be entered, e.g., cd directory.
                                            program and executed. Program
                                            files written in scripting languages
                                            must also be set as readable to be
                                            executed.
                        
                        ---> examples 

                                -rwx------              A regular file that is readable, writable, and executable by the file’s
                                                            owner. No one else has any access.
                                -rw-------              A regular file that is readable and writable by the file’s owner. No one else has any access.
                                -rw-r--r--              A regular file that is readable and writable by the file’s owner.
                                                            Members of the file’s owner group may read the file. The file is world-readable.
                                -rwxr-xr-x              A regular file that is readable, writable, and executable by the file’s
                                                            owner. The file may be read and executed by everybody else.
                                -rw-rw----              A regular file that is readable and writable by the file’s owner and
                                                            members of the file’s group owner only.
                                lrwxrwxrwx              A symbolic link. All symbolic links have “dummy” permissions. The
                                                            real permissions are kept with the actual file pointed to by the symbolic link.
                                drwxrwx---              A directory. The owner and the members of the owner group may
                                                            enter the directory and create, rename, and remove files within the directory.
                                drwxr-x---              A directory. The owner may enter the directory and create, rename,
                                                            and delete files within the directory. Members of the owner group
                                                            may enter the directory but cannot create, delete, or rename files.
        
    - chmod : change file mode (permission)

        -- only file's owner or the superuser can change the mode of a file or directory 

        -- chmod : supports two ways of specifying mode changes 

                -> Octal number representation 

                    --> code definition 
                        Octal       Binary          File mode
                        0           000             ---
                        1           001             --x
                        2           010             -w-
                        3           011             -wx
                        4           100             r--
                        5           101             r-x
                        6           110             rw-
                        7           111             rwx
                    
                    --> example 
                        ---> [me@linuxbox ~]$ > foo.txt
                                [me@linuxbox ~]$ ls -l foo.txt
                                -rw-rw-r-- 1 me me 0 2018-03-06 14:52 foo.txt
                                [me@linuxbox ~]$ chmod 600 foo.txt
                                [me@linuxbox ~]$ ls -l foo.txt
                                -rw------- 1 me me 0 2018-03-06 14:52 foo.txt
                        
                        ---> by passing 600, we were able to set the permissions of the owner to read and write while removing all perssions from the group owner and world

                -> symbolic representation 

                    --> components 
                        ---> who the change will affect 
                        ---> which operation will be performed 
                        ---> what permission will be set 
                    
                    --> 'u', 'g', 'o', 'a' : specifying who is affected 

                            u       Short for “user” but means the file or directory owner.
                            g       Group owner.
                            o       Short for “others” but means world.
                            a       Short for “all.” This is a combination of u, g, and o.
                        
                        ---> if no character is specified, 'all' will be assumed 

                        ---> can be used in combination with '+', for adding a permission and '-' for taking away a permission 
                    
                    --> 'r', 'w', 'x' : specifying permission modified 

                            u+x             Add execute permission for the owner.
                            u-x             Remove execute permission from the owner.
                            +x              Add execute permission for the owner, group, and world. This is equivalent to a+x.
                            o-rw            Remove the read and write permissions from anyone besides the owner and group owner.
                            go=rw           Set the group owner and anyone besides the owner to have read and write permissions. If either the group owner or the 
                                                world previously had execute permission, it is removed.
                            u+x,go=rx       Add execute permission for the owner and set the permissions for the group and others to read and execute. 
                                                Multiple specifications may be separated by commas.

        -- umask : set default permissions 

        -- special permissions 

                -> full permission mask is 4 instead of 3 digits 

                -> special types 

                    --> setuid bit : octal 4000
                        ---> it changes the effective user ID from the real user (who running the program) to program's owner 
                        ---> this allows the program to access files and directories that an oridnary user would normally be prohibited from accessing 

                    --> setgid bit : octal 2000
                        ---> changes the effective group ID from the real group ID of the real user to that of the file owner 
                        ---> this is useful in a shared directory when members of a common group need access to all the files in the directory, regardless of the file owner's primary group
                    
                    --> sticky bit: octal 1000
                        ---> it prevents users from deleting or renaming files unless the user is either the owner of the directory, the owner of the file, or the superuser
                        ---> this is often used to control access to a shared directory, such as /tmp 
    
    - change identities : 3 ways to take on an alternative identity for purposes such as testing an account

        -- log out and log back in

        -- 'su' : run a shell with substitute user and group IDs 

                -> su [-[l]] [user]
                    --> '-l' option enables the resulting shell session to be a login shell for the specified user 
                        ---> this means the user's environment is loaded and the working directory is changed to the user's home directory 
                        ---> '-l' can be abbreviated as '-'
                    --> if the user is not specified, the superuser is assumed

                -> example 
                    --> [me@linuxbox ~]$ su -
                        Password:
                        [root@linuxbox ~]#

                        [root@linuxbox ~]# exit
                        [me@linuxbox ~]$

                    --> executing a single command 
                        [me@linuxbox ~]$ su -c 'ls -l /root/*'
                        Password:
                        -rw------- 1 root root 754 2007-08-11 03:19 /root/anaconda-ks.cfg
                        /root/Mail:
                        total 0
                        [me@linuxbox ~]$
                            
        -- 'sudo' : execute a command as another user 

                -> the administrator can configure 'sudo' to allow an ordinary user to execute commands as a different user in a controlled way 
                    --> in particular, a user may be restricted to one or more specific commands and no others 

                -> the use of 'sudo' does not require access to the superuser's password 
                    --> authenticating using 'sudo' requires the user's own password 

                -> 'sudo' does not start a new shell, nor load another user's environment 
                    --> commands do not need to be quoted any differently than they would be without using 'sudo'
                
                -> after entering password for the first time, in the next few mintues, 'sudo' will not ask for re-entering password until its timer runs out 

                -> example 
                    --> [me@linuxbox ~]$ sudo backup_script
                        Password:
                        System Backup Starting...

                    --> list privileges granted by 'sudo'
                        [me@linuxbox ~]$ sudo -l
                        User me may run the following commands on this host:
                        (ALL) ALL

    - 'chown' : cange file owner and group

        -- chown [owner][:[group]] file...

                -> example arguments 
                        bob                         Changes the ownership of the file from its current owner to user bob.
                        bob:users                   Changes the ownership of the file from its current owner to user bob, and changes the file group owner to group users.
                        :admins                     Changes the group owner to the group admins. The file owner is unchanged.
                        bob:                        Changes the file owner from the current owner to user bob and changes the group owner to the login group of user bob.
                
                ->  [janet@linuxbox ~]$ sudo cp myfile.txt ~tony
                    Password:
                    [janet@linuxbox ~]$ sudo ls -l ~tony/myfile.txt
                    -rw-r--r-- 1 root root root 2018-03-20 14:30 /home/tony/myfile.txt
                    [janet@linuxbox ~]$ sudo chown tony: ~tony/myfile.txt
                    [janet@linuxbox ~]$ sudo ls -l ~tony/myfile.txt
                    -rw-r--r-- 1 tony tony tony 2018-03-20 14:30 /home/tony/myfile.txt

                    --> user janet copies the file from her directory to the home directory of user tony 
                    --> janet then changes the ownership of the file from root (a result of using 'sudo') to tony 
                    --> using the trailing colon, janet also changed the group ownership of the file to the login group of tony, which happens to be group tony  
    
    - 'passwd' : changing password

        -- it will try to enforce use of strong passwords

        -- example
                ->  [me@linuxbox ~]$ passwd
                    (current) UNIX password:
                    New UNIX password:
                    BAD PASSWORD: is too similar to the old one
                    New UNIX password:
                    BAD PASSWORD: it is WAY too short
                    New UNIX password:
                    BAD PASSWORD: it is based on a dictionary word


processes 

    - how a process works 

        -- system starts up 
                -> kernel initiates a few of its own processes and launches a program called 'init'
                -> 'init' runs a series of shell scripts (located in '/etc') called "init scripts" 
                -> start all the system services 

            --- many of the services are implemented as "daemon programs"
                ---- programs that just sit in the background and do their thing without having any user interface  
        
        -- the kernel maintains information about each process to help keep things organized

            --- each process is assigned a number called a "process ID (PID)" 
                ---- PIDs are assigned in ascending order, with 'init' always getting "PID 1"

            --- kernel also keeps track of 
                ---- memory assigned to each process 
                ---- processes' readiness to resume execution 
            
            --- like files, processes also have owners and user IDs, effective userIDs, and so on 
    
    - managing processes and terminal 

        -- why terminal "locks up" when ran a command like 'python script.py'
            --- the shell launches a foreground process - terminal is attached to that process's stdin/stdout/stderr 
            --- shell is suspended while the child process runs in the foreground 
        
        -- how to keep control while a process runs 

            --- run in the background 
                ---- '&': 'python script.py &'
                ---- the shell will start the process in the background 
                ---- you immediately get your prompt back 
                ---- you can check its PID (Process ID) and status using 
                        -> 'jobs', 'ps', 'top', 'htop'
                ---- you can still bring it to the foreground later with 
                        -> 'fg %1'

            --- suspend and background an existing process 
                ---- press 'Ctrl + Z' -> this suspends (pauses) the process
                ---- then run 'bg' to resume it in the background 
                ---- now you can inspect with 'jobs', 'ps', or 'top'         
    
    - viewing processes 

        -- 'ps' - snapshot of machine's state

                [me@linuxbox ~]$ ps
                    PID     TTY     TIME    CMD
                    5198    pts/1 00:00:00  bash
                    10129   pts/1 00:00:00   ps

            --- by default, 'ps' doesn't show very much, just the processes associated with the current terminal session 
            
            --- outputs 
                ---- "TTY" - teletype - "controlling terminal" for the process 
                ---- "TIME" - amount of CPU time consumed by the process 
            
            --- options 
                
                ---- 'ps x'
                        -> 'x' option tells 'ps' to show a list of every process that we own regardless of what terminal (if any) they are controlled by 
                        -> "?" in "TTY" indicates no controlling terminal
                        -> a new column "STAT"  - state - will be included and it reveals the current status of the process 

                        State   Meaning
                        R       Running. This means the process is running or ready to run.
                        S       Sleeping. The process is not running; rather, it is waiting for an event, such as a keystroke or network packet.
                        D       Uninterruptible sleep. The process is waiting for I/O such as a disk drive.
                        T       Stopped. The process has been instructed to stop. You’ll learn more about this later in the chapter.
                        Z       A defunct or “zombie” process. This is a child process that has terminated but has not been cleaned up by its parent.
                        <       A high-priority process. It’s possible to grant more importance to a process, giving it more time on the CPU. This property of a process is called niceness.
                                    A process with high priority is said to be less nice because it’s taking more of the CPU’s time, which leaves less for everybody else.
                        N       A low-priority process. A process with low priority (a nice process) will get processor time only after other processes with higher priority have been serviced.
                
                        -> the process state may be followed by other chars, indicating exotic process characteristics. see 'ps' man page for more details 
                
                ---- 'ps aux'

                        [me@linuxbox ~]$ ps aux
                            USER PID  %CPU   %MEM   VSZ     RSS     TTY     STAT    START   TIME    COMMAND
                            root 1    0.0     0.0   2136    644     ?       Ss      Mar05   0:31    init
                            root 2    0.0     0.0   0       0       ?       S<      Mar05   0:00    [kt]
                            root 3    0.0     0.0   0       0       ?       S<      Mar05   0:00    [mi]
                            root 4    0.0     0.0   0       0       ?       S<      Mar05   0:00    [ks]
                            root 5    0.0     0.0   0       0       ?       S<      Mar05   0:06    [wa]
                            root 6    0.0     0.0   0       0       ?       S<      Mar05   0:36    [ev]
                            root 7    0.0     0.0   0       0       ?       S<      Mar05   0:00    [kh]
                            --snip--
                    
                        -> this set of options displays the processes belonging to every user 
                
                ---- using options without leading dash invokes the command with "BSD-stype" behavior 

                        Header  Meaning
                        
                        USER    User ID. This is the owner of the process.
                        %CPU    CPU usage in percent.
                        %MEM    Memory usage in percent.
                        VSZ     Virtual memory size.
                        RSS     Resident set size. This is the amount of physical memory (RAM) the process is using in kilobytes.
                        START   Time when the process started. For values over 24 hours, a date is used.
                
        -- 'top' - dynamically vieweing processes 

            --- the 'top' program displays a continuously updating (default - every 3 seconds) display of the system processes listed in order of process activity 

            --- display 2 parts of information
                ---- a system summary at the top of the display 
                ---- a table of processes sorted by CPU activity 
            
            --- keyboard commands
                ---- 'h' - displays the program's help screen 
                ---- 'q' - quit 'top'
            
            --- graphical applications in Windows & macOS equivalence to 'top'
                ---- e.g., Task Manager 
                ---- 'top' is better - faster and consumes far fewer system resources 
            
            --- example 

                    top - 14:59:20 up 6:30, 2 users, load average: 0.07, 0.02, 0.00
                    Tasks: 109 total, 1 running, 106 sleeping, 0 stopped, 2 zombie
                    Cpu(s): 0.7%us, 1.0%sy, 0.0%ni, 98.3%id, 0.0%wa, 0.0%hi, 0.0%si
                    Mem: 319496k total, 314860k used, 4636k free, 19392k buff
                    Processes 103
                    Swap: 875500k total, 149128k used, 726372k free, 114676k cach
                    
                    PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND
                    6244 me 39 19 31752 3124 2188 S 6.3 1.0 16:24.42 trackerd
                    11071 me 20 0 2304 1092 840 R 1.3 0.3 0:00.14 top
                    6180 me 20 0 2700 1100 772 S 0.7 0.3 0:03.66 dbus-dae
                    6321 me 20 0 20944 7248 6560 S 0.7 2.3 2:51.38 multiloa
                    4955 root 20 0 104m 9668 5776 S 0.3 3.0 2:19.39 Xorg
                    1 root 20 0 2976 528 476 S 0.0 0.2 0:03.14 init
                    2 root 15 -5 0 0 0 S 0.0 0.0 0:00.00 kthreadd
                    3 root RT -5 0 0 0 S 0.0 0.0 0:00.00 migratio
                    4 root 15 -5 0 0 0 S 0.0 0.0 0:00.72 ksoftirq
                    5 root RT -5 0 0 0 S 0.0 0.0 0:00.04 watchdog
                    6 root 15 -5 0 0 0 S 0.0 0.0 0:00.42 events/0
                    7 root 15 -5 0 0 0 S 0.0 0.0 0:00.06 khelper
                    41 root 15 -5 0 0 0 S 0.0 0.0 0:01.08 kblockd/
                    67 root 15 -5 0 0 0 S 0.0 0.0 0:00.00 kseriod
                    114 root 20 0 0 0 0 S 0.0 0.0 0:01.62 pdflush
                    116 root 15 -5 0 0 0 S 0.0 0.0 0:02.44 kswapd0
            
            ---  'top' information fields 

                Row     Field       Meaning
                1       top         This is the name of the program.

                        14:59:20    This is the current time of day.

                        up 6:30     This is called uptime. It is the amount of time since the machine was last booted. In this example, the system has been up for six and a half hours.

                        2 users     There are two users logged in.
                        
                    load average:   Load average refers to the number of processes that are waiting to run; that is, the number of processes that are in a runnable state and are sharing the CPU. 
                                        Three values are shown, each for a different period of time. The first is the average for the last 60 seconds, the next the previous 5 minutes,
                                        and finally the previous 15 minutes. Values less than 1.0 indicate that the machine is not busy.

                2       Tasks:      This summarizes the number of processes and their various process states. 
                
                3       Cpu(s):     This row describes the character of the activities that the CPU is performing.
                                        0.7%us 0.7 percent of the CPU is being used for user processes. This means processes outside the kernel.
                                        1.0%sy 1.0 percent of the CPU is being used for system (kernel) processes.
                                        0.0%ni 0.0 percent of the CPU is being used by “nice” (low-priority) processes.
                                        98.3%id 98.3 percent of the CPU is idle.
                                        0.0%wa 0.0 percent of the CPU is waiting for I/O.

                4       Mem:        This shows how physical RAM is being used.

                5       Swap:       This shows how swap space (virtual memory) is being used.
            
    - controlling processes 

        -- experiment with program 'xlogo'
            --- notice that while the program is running, our shell prompt has not returned - because the shell is waiting for the program to finish 

        -- interrupting a process 

            --- 'CTRL-C' interrupts a program 
                ---- we are politely asking the program to terminate 
                ---- xlogo window closed, and the shell prompt returned 
            
            --- many (but not all) command line programs can be interrupted by using this technique
        
        -- putting a process in the background 

            --- terminal has 
                ---- foreground (with stuff visible on the surface like the shell prompt)
                ---- background (with stuff hidden behind the surface)
            
            --- 'xlogo &' - launch program so that it is immediately placed in the background 

                ---- after the command, program runs, and the shell prompt returned

                ---- "job control" is also printed, the shell is telling us 
                        -> we have started job number 1 [1] 
                        -> it has PID 28236

                ---- if we run 'ps' - we can see the process 

                        [me@linuxbox ~]$ ps
                                PID TTY TIME CMD
                                10603 pts/1 00:00:00 bash
                                28236 pts/1 00:00:00 xlogo
                                28239 pts/1 00:00:00 ps
                
                ---- 'jobs': shell's job control facility lists the jobs that have been launched from our terminal 

                        [me@linuxbox ~]$ jobs
                            [1]+ Running xlogo &
                
                        -> we have one job, numbered 1; that it is running; and that the command was 'xlogo &'
        
        -- returning a process to the foreground 

            --- background process is immune from terminal keyboard input - including 'CTRL-C'

            --- to bring a process to the foreground 

                    [me@linuxbox ~]$ jobs
                    [1]+  Running                 xlogo &
                    [me@linuxbox ~]$ fg %1
                    xlogo

        -- stopping (pausing) a process 

            --- 'CTRL-Z' - suspend a process 

            --- 'fg %1' - resume process in the foreground 

            --- 'bg %1' - resume process in the background 
        
        -- why would we want to launch a program from the command line 
            --- program not listed on the window manager's menu 
            --- might be able to see error messages that would otherwise be invisible if the program were launched graphically 
                ---- sometimes, a program will fail to start up when launched from the graphical menu 
    
    - signals 

        -- 'kill' - used to "kill" processes 

                [me@linuxbox ~]$ xlogo &
                [1] 28401
                [me@linuxbox ~]$ kill 28401
                [1]+  Terminated              xlogo
        
            --- we can also use a jobspec (e.g., %1) instead of a PID 
        
            --- it doesn't "kill" processes - it sent "signals"

                ---- 'CTRL-C' and 'CTRL-Z' are signals 
                        -> when terminal receives one of these keystrokes, it sends a singal to the program in the foreground 
                        -> 'CTRL-C' - "INT" singnal (interrupt) 
                        -> 'CTRL-Z' - "TSTP" signal (terminal stop)
                
                ---- programs "listen" for signals and may act upon them as they are received 
                        -> the fact that a program can listen and act upon signals allows a program to do things such as save work in progress when it is sent a termination signal 
        
        -- sending signals to processes with 'kill'

            --- 'kill -signal PID...'

                ---- when no signal is specified, "TERM" (terminal) signal is sent by default 

                ---- signals 

                    Number  Name        Meaning
                    1       HUP         Hang up. This is a vestige of the good old days when terminals were attached to remote computers with phone lines and modems. 
                                            The signal is used to indicate to programs that the controlling terminal has “hung up.” The effect of this signal can be demonstrated 
                                            by closing a terminal session. The foreground program running on the terminal will be sent the signal and will terminate.
                                            This signal is also used by many daemon programs to cause a reinitialization. This means that when a daemon is sent this signal, 
                                            it will restart and reread its configuration file. The Apache web server is an example of a daemon that uses the HUP signal in this way.

                    2       INT         Interrupt. This performs the same function as ctrl-c sent from the terminal. It will usually terminate a program.
                    
                    9       KILL        Kill. This signal is special. Whereas programs may choose to handle signals sent to them in different ways, including ignoring them all together, 
                                            the KILL signal is never actually sent to the target program. Rather, the kernel immediately terminates the process. When a process is 
                                            terminated in this manner, it is given no opportunity to “clean up” after itself or save its work. For this reason, the KILL signal 
                                            should be used only as a last resort when other termination signals fail.
                    
                    15      TERM        Terminate. This is the default signal sent by the kill command. If a program is still “alive” enough to receive signals, it will terminate.
                    
                    18      CONT        Continue. This will restore a process after a STOP or TSTP signal. This signal is sent by the bg and fg commands.
                    
                    19      STOP        Stop. This signal causes a process to pause without terminating. Like the KILL signal, it is not sent to the target process, and thus it cannot be ignored.
                    
                    20      TSTP        Terminal stop. This is the signal sent by the terminal when ctrl-Z is pressed. Unlike the STOP signal, the TSTP signal is received by the program, 
                                            but the program may choose to ignore it
            
            --- processes, like files, have ownders, and you must be the owner of a process (or superuser) to send it signals with kill

                ---- 'kill -l' - display a complete list of signals 
        
        -- sending signals to multiple processes with 'killall'

            --- 'killall [-u user] [-signal] name...'

                    [me@linuxbox ~]$ xlogo &
                    [1] 18801
                    [me@linuxbox ~]$ xlogo &
                    [2] 18802
                    [me@linuxbox ~]$ killall xlogo
                    [1]-  Terminated              xlogo
                    [2]+  Terminated              xlogo
    
    - shutting down the system 

        -- involves 
            --- orderly termination of all the processes on the system 
            --- performing some vital housekeeping chores (such as syncing all of the mounted file systems)
        
        -- commands 

            --- 'halt', 'poweroff', 'reboot'
                ---- generally used without any command line options 
                ---- 'sudo reboot'
            
            --- 'shutdown'
                ---- it allows you to specify which of the actions to perform (halt, power down, or reboot) 
                ---- it also allows a time delay to the shutdown event 
                ---- examples 
                        -> 'sudo shutdown -h now'
                        -> 'duso shutdown -r now'
        
    - more process-related commands 

        -- becuase monitoring processes is an important system administration task, there are a lot of commands for it

                Command     Description

                pstree      Outputs a process list arranged in a tree-like pattern showing the parent child relationships between processes.

                vmstat      Outputs a snapshot of system resource usage including memory, swap, and disk I/O. To see a continuous display, follow the command with a time delay 
                                (in seconds) for updates. Here’s an example: vmstat 5. Terminate the output with ctrl-c.

                xload       A graphical program that draws a graph showing system load over time.

                tload       Similar to the xload program but draws the graph in the terminal. Terminate the output with ctrl-c. 
 

the environment 

    - the shell maintains a body of information during our shell session called the environment 
        -- programs use the data stored in the environment to determine facts about the system's configuration 
        -- while most programs use configuration files to store program settings, some programs also look for values stored in the environment to adjust their behavior 
        -- we can use the environment to customize our shell exerience 
    
    - what is stored in the environment 

        -- shell stores few basic types of data in the environment 

            --- variables 
                ---- shell variables 
                ---- environment variables 
                        -> with Bash, these are largely indistinguishable because 'bash' can promote a shell variable to an environment variable using 'export' - same syntax, same namespace
            
            --- programmatic data 
                ---- aliases 
                ---- shell functions 
    
        -- examining the environment

            --- 'set' command will show both the shell and environment variables, and any defined shell functions  

                ---- unlike 'printenv' - output is sorted in alphabetical order 

                ---- 'set | less'

            --- 'printenv' only displays environment variables 
                
                ---- 'printenv | less'
                        USER=me
                        PAGER=less
                        LSCOLORS=Gxfxcxdxbxegedabagacad
                        XDG_CONFIG_DIRS=/etc/xdg/xdg-ubuntu:/usr/share/upstart/xdg:/etc/xdg
                        PATH=/home/me/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/
                        bin:/usr/games:/usr/local/games
                        DESKTOP_SESSION=ubuntu
                        QT_IM_MODULE=ibus
                        QT_QPA_PLATFORMTHEME=appmenu-qt5
                        JOB=dbus
                        ...
                
                ---- 'printenv USER' - list the value of a specific variable 
            
            --- 'echo' - view contents of a variable

                [me@linuxbox ~]$ echo $HOME
                    /home/me
            
            --- 'alias' - to view aliases - becauase neither 'set' nor 'printenv' shows aliases 

        -- interesting variables 

            --- we will likely see these variables in our environment - they vary by distribution though 

                Variable    Contents
                DISPLAY     The name of your display if you are running a graphical environment. Usually this is :0, meaning the first display generated by the X server.

                EDITOR      The name of the program to be used for text editing. 
                
                SHELL       The name of your shell program.

                HOME        The pathname of your home directory.

                LANG        Defines the character set and collation order of your language.

                OLDPWD      The previous working directory.

                PAGER       The name of the program to be used for paging output. This is often set to /usr/bin/less.

                PATH        A colon-separated list of directories that are searched when you enter the name of a executable program.

                PS1         Stands for “prompt string 1.“ This defines the contents of the shell prompt. As we will later see, this can be extensively customized.

                PWD         The current working directory.

                TERM        The name of your terminal type. Unix-like systems support many terminal protocols; this variable sets the protocol to be used with your terminal emulator.

                TZ          Specifies your time zone. Most Unix-like systems maintain the computer’s internal clock in Coordinated Universal Time (UTC) and then display the
                                local time by applying an offset specified by this variable.

                USER        Your username.
        
    - how is the environment established 

        -- typical sequence 

            --- log on to system
                -> 'bash' starts and reads a series of configuration scripts called "startup files" - defines the default environment shared by all users 
                -> more startup files in our home directory - defines our personal environment 
            
            --- exact sequence depends on the type of shell session being started 

                ---- a login shell session (SSH)
                        -> this is where we are prompted for you username and password 
                        -> happens when we start a virtual console session, for example 
                        -> typical startup files 

                         File               Contents
                        /etc/profile        A global configuration script that applies to all users.

                        ~/.bash_profile     A user’s personal startup file. It can be used to extend or override settings in the global configuration script.

                        ~/.bash_login       If ~/.bash_profile is not found, bash attempts to read this script.
                        
                        ~/.profile          If neither ~/.bash_profile nor ~/.bash_login is found, bash attempts to read this file. This is the default in Debian-based distributions, 
                                                such as Ubuntu.

                ---- a non-login shell session 
                        -> occurs when lunching a terminal session in the GUI 
                        -> typical startup files 

                         File               Contents
                        /etc/bash.bashrc    A global configuration script that applies to all users.
                        ~/.bashrc           A user’s personal startup file. It can be used to extend or override settings in the global configuration script. 'rc' means "run commands"

                        -> in addition to reading these files, non-login shells inherit the environment from their parent process, usually a login shell 

                ---- the '~/.bashrc' file is probably the most important startup file from the ordinary user's point of view, because it is almost always read 
                        -> non-login shells read it by default 
                        -> most startup files for login shells are written in such a way as to read the '~/.bashrc' file as well 
                
                ---- mental model for two kinds of shell sessions 
                        -> login shell sets the "root" environment - created by a login shell (environment accessible to all subshells)
                        -> non-login shells inherit the root environment (then add interactive niceties from '.bashrc')
                            --> local terminal only runs non-login shells without login shell constrcuting "root environment" 
                            --> local "root environment" is not created by a bash env 
                            --> local environment set by system 
                                ---> '/etc/environment'
                                ---> '/etc/security/pam_env.conf'
                                ---> '.pam_environment'
                                ---> sometimes '.profile' (not guaranteed)
                                ---> '.xprofile' or '.xsessionrc' if the DE chooses 
                
                ---- importance 
                        -> non-login vs. login shell knowledge is a practical DevOps skill
                        -> "root CLI environment" created by a login shell is the environment Azure VMs, Databricks jumpboxes, Kubernetes pods, etc. expect you to understand 
        
        -- what is in a startup file?

            --- a typical '.bash_profile' (from CentOS 6 system)

                    # .bash_profile
                    # Get the aliases and functions
                    if [ -f ~/.bashrc ]; then
                            . ~/.bashrc
                    fi
                    # User specific environment and startup programs
                    PATH=$PATH:$HOME/bin
                    export PATH
            
                ---- lines begin with "#" - comments 

                ---- "if compound command" translation - 'if ... fi'

                        If the file "~/.bashrc" exists, then
                            read the "~/.bashrc" file.
                
                        -> this is how a login shell gets the contents of '.bashrc'
                
            --- 'PATH' - how does shell know where to find commands when entered on the command line 

                ---- the shell searches a list of directories that are contained in the 'PATH' variable 

                ---- the PATH variable is often (but not always, depending on distribution) set by the '/etc/profile' startup file with this code 
                        -> 'PATH=$PATH:$HOME/bin'
                        -> PATH is modified to add the directory '$HOME/bin' to the end of the list 
                        -> then, the directory '$HOME/bin' is added to the list of directories searched when a command is entered 
                        -> means, we can create a directory within our home directory for storing our own private programs 
                
                ---- note:
                        -> many distributions provide this PATH setting by default 
                        -> Debian-based distributions, such as Ubuntu, test for existence of the '~/bin' directory at login and dynamically add it to the PATH variable if the directory is found
                
                ---- 'export PATH'
                        -> the 'export' command tells the shell to make the contents of PATH available to child processes of this shell 
        
        -- modifying the environment 
        
            --- which files should we modify?

                ---- to add directories to PATH or define additional environment variables - place those in '.bash_profile' (or '.profile' in Ubuntu)

                ---- everything else - place the change in '.bashrc'
            
            --- text editors - for actual editing 

                ---- graphical editors 

                ---- text-based editors 

        -- using a text editor 

            --- syntax: "editor_name" followed by "file_name" 

            --- good habit: always back up file first 
                ---- 'cp .bashrc .bashrc.bak'
            
            --- 'nano .bashrc'

                        GNU nano 2.0.3 File: .bashrc
                        
                    # .bashrc

                    # Source global definitions
                    if [ -f /etc/bashrc ]; then
                    . /etc/bashrc
                    fi

                    # User specific aliases and functions

                                        [ Read 8 lines ]
                    ^G Get Help ^O WriteOut ^R Read Fil ^Y Prev Pag ^K Cut Text ^C Cur Pos
                    ^X Exit     ^J Justify  ^W Where Is ^V Next Pag ^U UnCut Te ^T To Spell
                
                ---- common commands 
                        -> 'CTRL-X' - exit
                        -> 'CTRL-O' - save 

                ---- adding commands (along with comments!!!!)

                    umask 0002
                    export HISTCONTROL=ignoredups
                    export HISTSIZE=1000
                    alias l.='ls -d .* --color=auto'
                    alias ll='ls -l --color=auto'
                
                ---- meaning 

                    Line                                Meaning

                    umask 0002                          Sets the umask to solve the problem with the shared directories we discussed in Chapter 9.

                    export HISTCONTROL=ignoredups       Causes the shell’s history recording feature to ignore a command if the same command was just recorded.
                    
                    export HISTSIZE=1000                Increases the size of the command history from the usual default of 500 lines to 1,000 lines.

                    alias l.='ls -d .* --color=auto'    Creates a new command called l., which displays all directory entries that begin with a dot.
                    
                    alias ll='ls -l --color=auto'       Creates a new command called ll, which displays a long-format directory listing.
            
            --- activate our changes 

                ---- '.bashrc' can be read through 
                        -> restart terminal 
                        -> 'source ~/.bashrc'
   
    
intro to VI 

    - why vi?
        -- vi is amost always available - POSIX, a standard for program compatibility on Unix systems, requires that vi be present 
        -- vi is lightweight and fast - vi is designed for typing speed 
        -- don't want other Linux and Unix users to think we are cowards 
    
    - starting and stopping vi 

        -- 'vi'

                ~
                ~
                ~                         VIM - Vi Improved
                ~
                ~                          version 8.0.707
                ~                     by Bram Moolenaar et al.
                ~            Vim is open source and freely distributable
                ~
                ~                     Sponsor Vim development!
                ~          type  :help sponsor<Enter>    for information
                ~
                ~          type  :q<Enter>               to exit
                ~          type  :help<Enter>  or  <F1>  for on-line help
                ~          type  :help version8<Enter>   for version info
                ~
                ~                   Running in Vi compatible mode
                ~          type  :set nocp<Enter>        for Vim defaults
                ~          type  :help cp-default<Enter> for info on this
                ~
                ~
            
            --- quit & force quit 
                ---- ':q'
                ---- ':q!'
        
    - editing modes 

        -- 'vi foo.txt': open/create a new file 

                    ~
                    ~
                    ~
                    ~
                    ~
                    ~
                    ~
                    ~
                    ~
                    ~
                    ~
                    ~
                    "foo.txt" [New File]
            
            --- '~' indicates that no text exists on that line 
        
        -- "command mode"

            --- when vi starts, it begains in "command mode" - almost every key is a command - or "normal mode"

                ---- 'i'    -> enter insert mode 
                ---- 'dd'   -> delete a line 
                ---- '/'    -> search 
                ---- 'u'    -> undo 
                ---- 'yy'   -> yank (copy) a line 

        -- entering "insert mode"

            --- 'i' and observe at the bottom 

                    "-- INSERT --"

            --- we can start typing 

            --- press 'ESC' key to excit insert mode 
        
        -- "command-line mode": e.g., saving our work 

            --- ':w'

            --- and file will be written to hard drive, and observe the confirmation message at the bottom 

                        "foo.txt" [New] 1L, 46C written
            
            --- commands 

                ---- ':w'               -> save 
                ---- ':q'               -> quit 
                ---- ':wq'              -> save and quit 
                ---- ':help'            -> help 
                ---- ':set number'      -> show line numbers 
        
    - moving the cursor around  

        -- in "command mode", vi offers a large number of movement commands, some of which shares with 'less'

                Key                     Moves the cursor

                l or right arrow        Right one character.
                
                h or left arrow         Left one character.

                j or down arrow         Down one line.

                k or up arrow           Up one line.

                0 (zero)                To the beginning of the current line.

                ^                       To the first non-whitespace character on the current line.

                $                       To the end of the current line.

                w                       To the beginning of the next word or punctuation character.

                W                       To the beginning of the next word, ignoring punctuation characters.

                b                       To the beginning of the previous word or punctuation character.
                
                B                       To the beginning of the previous word, ignoring punctuation characters.

                ctrl-F or page down     Down one page.

                ctrl-B or page up       Up one page.
                
                numberG                 To line number. For example, 1G moves to the first line of the file.

                G                       To the last line of the file.
            
            --- many commands in vi can be prefixed with a number, as with the G command
            --- by prefixing a command with a number we may specify the number of times a command is to be carried out 
            --- e.g., '5j' causes vi to move the cursor down five lines 
        
    - basic editing 

        -- common options 
            
            --- undo
                ---- 'u' key in command mode, undo the last change that you made
        
        -- appending text ('i' vs. 'a')

            --- gist 
                ---- 'i' insert before the cursor 
                ---- 'a' append after the cursor 
            
            --- both enter insert mode, but the cursor position is different 

                    H e l l o
                            ^
                        cursor on 'o'
                
                ---- if you press 'i' - enter insert mode before "o", so typing "!!!!" gives 
                        -> Hell!!!!o 
                
                ---- if you press 'a' instead - cursor moves one step to the right - so typing "!!!!" gives 
                        -> Hello!!!!
            
            --- variations 

                ---- 'A' - move to the end of the current line and start appending 
        
        -- opening a line - another way to insert text 

            ---  inserts a blank line between two existing lines and enter insert mode

            --- keys 
                ---- 'o' - the line below the current line 
                ---- 'O' - the line above the current line 
        
        -- deleting text 

            --- keys 

                ---- 'x' - delete a character at the curosr location  - deletes a fixed size 
                        -> 'x' may be preceded by a number specifying how many characters are to be deleted 
                        -> always deletes characters, nothing else 
                        -> always forward (right)
                        -> always a fixed amount 
                        -> never uses motions (except with numbers)
                
                ---- 'd' - deletes a region of text spelled out by a movement 
                        -> 'd' is waiting for you to tell it the shape of what to delete 
                        -> examples 
                            --> 'dw' - delete to the start of next word 
                            --> 'de' - delete to the end of word 
                            --> 'd$' - delete to end of line 
                            --> 'd0' - delete to beginning of line 
                            --> 'd3w' - delete 3 words 
                            --> 'dap' - delete a paragraph
                            --> 'di(' - delete inside parentheses
                            --> 'da"' - delete a quoted string
                            --> 'dd' - delete the current line 
                            --> '5dd' - delete the current and the next four lines 
                            --> 'd^' - delete to the first non-whitespace character in the line 
                            --> 'dG' - delete to the end of the file 
                            --> 'd20G' - delete to line 20
        
        -- cutting, copying, and pasting text 

            --- keys 

                ---- 'd' - not only deletes text, it also "cuts" text 

                ---- 'p' - paste the contents of the buffer either before ('p') or after ('P') the cursor 

                ---- 'y' - copy text 

                        Command         Copies

                        yy              The current line

                        5yy             The current line and the next four lines

                        yW              From the current cursor position to the beginning of the next word

                        y$              From the current cursor location to the end of the current line

                        y0              From the current cursor location to the beginning of the line

                        y^              From the current cursor location to the first non-whitespace character in the line

                        yG              From the current line to the end of the file

                        y20G            From the current line to the twentieth line of the file

                        -> '"+y + ENTER' - copy to system clipboard
        
        -- linewise motion vs. characterwise motion 

            --- motions that are always linewise  
                ---- 'G'    -> go to last line 
                ---- 'gg'   -> go to first line 
                ---- 'j'    -> with a count in visual line mode 
                ---- 'k'    -> with a count in visual line mode 
                ---- 'V'    -> visual line mode 
                ----        -> any motion done inside 'V' mode 
                ---- 'mj' or 'mk' if marks represent whole lines 
                ---- '{' and '}' (paragraph motions)

            --- motions that are always characterwise 
                ---- '$'    -> end of line 
                ---- '0'    -> beginning of line 
                ---- '^'    -> first non-blank 
                ---- 'W', 'b', 'e', 'ge', etc. 
                ---- 'f<char>', 't<char>'
                ---- ';', ','
                ---- 'h', 'l'
                ---- 'j', 'k' (when used without a count in operator-pending mode) 
                ---- '(', ')' (sentence motions)
                ---- '%' (matching bracket)
        
        -- visual line mode 

            --- three visual modes 

                ---- 'v' -> visual (character) mode - highlights characters 
                ---- 'V' -> visual line mode - highlights entire lines, this is "linewise selection"
                ---- 'Ctrl+v' -> visual block mode - highlights a rectangle block of columns 
            
            --- 'V' means "I want to work with whole lines" - anything you do inside 'V' is guaranteed linewise 

            --- 'y2j' - enter and select in "character model" - press 'y' to copy and exit 

            --- 'Y2j' - enter and select in "Visual line mode" - press 'y' to copy and exit  

        -- join lines 

            --- normally, it is not possible to move the cursor to the end of a line and delete the end-of-line character to join one line with the one below it 

            --- 'J' can be used to join lines together 
    
    - search-and-replace 

        -- capabilities 
            --- move cursor to locations based on searches  
            --- can do this either on a single line or over an entire file 
            --- also perform text replacements with or without confirmation from the user 
        
        -- search within a line 

            --- 'f' command searches a line and moves the cursor to the next instance of a specified character 
                ---- 'fa' - move the cursor to the next occurrennce of the character "a" within the current line

            --- after performing a character search within a line, the search may be repeated by typing a ';'

        -- searching the entire file 

            --- '/' command moves the cursor to the next occurrence of a word of phrase
                ---- '/' will appear at the bottom of the screen when you type the command 
                ---- next, type the word or phrase to be searched for, followed by the ENTER key 
                ---- the cursor will move to the next location containing the search string 
                ---- 'n' command: a search may be repeated using the previous search string
        
        -- global search and replace 

            --- 'ex' - "substitution" over a range of lines or the entire file 

            --- ':%s/Line/line/gc' - change word "Line" to "line" for the entire file 

                ---- ':' - starts an 'ex' command 

                ---- '%'  
                        -> specifies the range of lines for the operation 
                        -> '%' is a shortcut meaning from the first line to the last line 
                        -> alternatively, the range could have been specified '1, 5' or '1, $' which means from line 1 to the last line in the file 
                        -> if range is omitted, the operation is performed only on the current line 
                
                ---- 's' 
                        -> specifies the operation
                        -> 's' is substitution (search and replace)
                
                ---- '/Line/line/' - specifies the search pattern and the replacement text 

                ---- 'g'
                        -> this means "global" - substitution is performed on every instance 
                        -> if omitted, only the first instance of the search string on each line is replaced 
                
                ---- 'c' 
                        -> substitution with user confirmation
                        -> before each substitution, vi stops and asks to confirm the substitution with message 
                        -> "replace with Line (y/n/a/q/l/^E/^Y)?"
                            --> 'y' - perform the substitution 
                            --> 'n' - skip this instance of the pattern 
                            --> 'a' - perform the substitution on this and all subsequent instances of the pattern 
                            --> 'q' or ESC - quit subsituting 
                            --> 'l' - perform this substitution and then quit, this is short for "last"
                            --> 'CTRL-E', 'CTRL-Y' - scroll down and scroll up, respectively , this is useful for viewing the context of the proposed substitution 

    - editing multiple files 

        -- 'vi fil1 fil2 fil3' - open multiple files for editing by specifying them on the command line

        -- switching between files 
            
            --- ':bn' - from one file to the next
            --- ':bp' - move back to previous file

            --- vi prevents from switching files if the current file has unsaved changes
                ---- to force swtiching - add '!'

            --- ':buffers'  - view a list of files being edited
            --- ':buffer n' - switch to another buffer (file) 

        -- opening additional files for editing
            
            --- ':e file_name' - open an additional file 

        -- copying content from one file into another

            --- ':buffer 1'     - switching to file 1
            --- 'yy'            - yank the first line
            --- ':buffer 2'     - switching to file 2
            --- 'p'             - paste the line

        -- inserting an entire file into another 
            
            --- 'vi file1'      - open file 1
            --- ':r file2'      - inserts file 2 below the cursor position

        -- save our work 
            
            --- 'ZZ'        - save current file and exit vi
            --- ':w file1'  - save current file as file1 - save an alternative version
                ---- as you continue to make edits, you are still editing current file, not file1
            

customizing the prompt

    - anatomy of a prompt 


        





            
            

    

        


                



                    












                






















temp notes

    - shell scripting 

        -- important components 

            --- '#!/usr/bin/env bash'
                ---- '#!' means it is interpreted by the kernel, not by the shell (shebang, hash-bang)
                ---- when script is executable and run directly (e.g., ./script.sh)
                        -> kernel reads the first two bytes 
                        -> if it sees '#!', it treats the rest of the line as the interpreter to run 
                ---- '#!/usr/bin/env bash' means 
                        -> run '/usr/bin/env' with argument 'bash', which finds 'bash' on PATH, then executes this script with that 'bash'
            
            --- 'chmod +x'
                ---- makes a file executable (adds the "execute" permission bit)
                ---- '+x' adds execute permission 
                        -> 'u+x' --> user/owner only 
                        -> 'g+x' --> group only 
                        -> 'o+x' --> others only 
                        -> 'a+x' --> all (same as plain '+x')
                ---- typical pattern 
                        -> 'chmod +x script.sh' # make it runnable 
                        -> './script.sh'        # run it 

            --- 'set -euo pipefail'
                ---- "bash strict mode" - it makes scripts fail fast and loudly when something goes wrong 
                        -> '-e' (errexit): exit the script if any simple command fails (exit status != 0)
                        ->'-u' (nounset): using an unset variable is an error (helps catch typos)
                        -> '-o pipefail' (pipefail): in a pipeline 'a | b | c', return the first non-zero exit status (without this, bash only returns 'c' 's status)  
                ---- put it near the top of your bash script, right after the shebang 
            
            --- useful functions 






                    





            













































